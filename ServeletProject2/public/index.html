
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<!-- Highlight.js -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/vs.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<!-- main.js -->
	<script type="text/javascript" src="main.js" defer></script>
	<!-- css -->
	<link rel="stylesheet" href="styles.css">
	<!--fontawesome link for drop navigation bar  -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<title>Javascript Turtorial</title>
	
</head>		

<body>
	<div class="topnav" id="myTopnav">
		<a href="index.html" class="active">Home</a>
		<a href="index.html" class="active">Javascript</a>
		<a href="mysql_turtorial.html">MySQL</a>
		<a href="dom.html">DOM</a>
		<a href="java.html">Java</a>
		<a href="jsp.html">JSP</a>
		<a href="servlet.html">Servlet</a>
		<a href="about.html">About</a>
		<a href="javascript:void(0);" class="icon" onclick="myFunction()">
			<i class="fa fa-bars"></i>
		</a>
	</div>
	<h1>Javascript Turtorial</h1>
	<div class="header_image">
	<img src="\pleiades\2022-09\workspace\ServeletProject2\headerIMG.jpg" alt="img"  width="390px"height="320px">
	</div>
	<p>こちらはとにかく例を貼りまくったサイトになります。わからない例題は、グーグルのコンソールをつかって実装することをお勧めします。キーワードを指定してください。コマンドFまたはコントロールFを使うことをお勧めします。</p>
	<p>特にわからなかったところ</p>
	 
	<ol>
		<li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Functions">関数</a></li>
		<li><a href="https://developer.mozilla.org/ja/docs/Glossary/Callback_function">コールバック関数</a></li>
		<li><a href="https://takayamato.com/eventlistener/">documentcontentloaded vs loaded</a></li>
		<li><a href="https://takayamato.com/eventlistener/">式と文</a></li>
		<li><a href="https://jsprimer.net/basic/operator/#ternary-operator">三項演算子</a></li>
	</ol>
	
	<!-- Add icon library -->




<!--	<h3>Function ! document.getElementById textContent = ()</h3>
	<p id="output"></p>
	<p id="output1"></p>
	<p id="output2"></p>

	<h3>For Statement,document.getElementById insertAdjacentHTML </h3>
	<p> insertAdjacentHTML() は、第二引数で指定するテキストを HTML または XML としてパースし、
		その結果であるノードを DOM ツリー内の指定された位置（第一引数で指定）に挿入します。
		これは挿入先の要素を再度パースするものではないため、既存の要素や要素内部の破壊を伴いません。
		余分なシリアル化のステップを回避できる分、 innerHTML
		への代入による直接的な操作よりもはるかに高速な動作となります。
	</p>
	<p>To do List</p>
	<ul id="list">
	</ul>

	<h4 id="array">Array List Using Json</h3>
	<p>Javascriptの配列はいろいろな型を入れることができる。</p>

	<table>
		<tr>
			<td id="name"></td>
			<td id="age"></td>
			<td id="city"></td>
		</tr>
	</table>

	<p id="arrybox"></p>
	<p id="microsoftComputers_name"></p>
	<p id="microsoftComputers_colors"></p>
	<p id="microsoftComputers_price"></p>
-->

<h3>letを使い変数を作る。</h3>
<ul>
<li>=の右側値を「初期値」</li>
<li>変数のValue変更可能。</li>
<li>再代入VS再宣言の違い。</li>
</ul>
<pre>
<code>
let apple = "Mac";
console.log(apple);
 //expected Mac

//代入できる。
apple="iphone";
console.log(apple);
//expected iphone

//再宣言
let a = 0;
let a = 1;//error

var a = 0;
var a = 1; //Varの場合再宣言可能　非推奨
//再代入

let a = 0;
a = 1;
console.log(a); //expected 1

const a = 0;
a = 9; //error
</code>
</pre>
<h3>constを使い定数を作る。</h3>
<ul>
<li>constに再代入はできない。</li>
<li>定数をつかうことで後からの修正が可能になる。</li>
<li>コードが変数に代わるので読みやすくなる。</li>
<li>2つを除いて特殊な記号は変数名には入れることはできない。</li>
<li>「$」「_」ドルマークとアンダーバーは変数にいれることができる。</li>
<li>変数名に対して、数字は先頭に来てはいけない。</li>
<li>変数名は一般的に英語で書く。</li>
<li>単語単語で区切る時には、キャメルケース。単語の初めは大文字。-> appleBanana　→グーグル推奨</li>
<li>あとはアンダースコアーで区切る。スネークケース　-> apple_Banana　一般的には使わない。</li>
</ul>
<pre>
<code>
const apple = "Mac";

console.log(apple) //expected Mac

//constに再代入はできない。
apple = "ipad";
console.log(apple);
//expected エラーが起きます。
</code>
</pre>


<h3>関数スコープ　ブロックスコープ</h3>
<dl>
    <dt>関数スコープ</dt>
    <dd>関数の中でしか変数を呼べない</dd>
    <dd>関数の外からは変数を呼べない。</dd>
    <dt>ブロックスコープ</dt>
    <dd>letとconstを使う。Varは使えない。</dd>
    <dd>ブロック内であると、関数宣言は無視される。つまり外側から呼べる。</dd>
    <dd>関数式は呼び出せない。関数に変数を代入すること。これはブロック内で変数として扱われるから。</dd>

</dl>

<pre>
<code>
function a(){
	//関数スコープ
	let b = 0;
	console.log(b); //expected 0
}

console.log(b) // error


{
	//ブロック
	let c = 1;
	console.log(c); //expected 1
	
	//もしvarを使った場合は外側から呼ばれる。非推奨。
	//var c = 1;
	
	function d() {
		console.log('d is called')
	}
	
	const d = function (){
		console.log('d is called again')
	}
}

console.log(c) //error 

d() //d is called

console.log(d) //関数式を呼び出すことはできない。
</code>
</pre>
<h3>クロージャー　静的な関数生成</h3>
<dl>
    <dt>レキシカルスコープの変数を関数が使用している状態。</dt>
    <dd>クロージャーを使ってプライベート変数を作る。</dd>
    <dd>関数のスコープ内で変数を宣言してあげると外側からアクセスは不可能になる。</dd>
</dl>

<pre>
<code>
//クロージャー
function fn1(){
	let b = 1;
	function fn2(){
		console.log(b);
	}
	fn2();
}
fn1(); //expected 1

//クロージャーを使ってプライベート変数を作る。

//example 1 
//numをグローバル変数におくと。。。どこからでも変更可能になってしまう。 

let num = 0 //どこからでもアクセス可能

function increment(){
	num += 1;
	console.log(num);
}　

increment(); 
 
 
//example 2  
funciton incrementFactory(){
	
	//関数のスコープ内にはいってるから外側からはアクセス不可能。
	let num = 0; 
	
	function increment(){
		num += 1;
		console.log(num)
	}
	return increment;
}

const increment = incrementFactory();

increment();//expected 1
increment();//expected 2
increment();//expected 3
</code>
</pre>

<h3>クロージャー（動的な関数生成）</h3>
<dl>
    <dt>関数を設定する関数に渡す値を変更すると出力結果が変わるので動的な関数といいます。</dt>
    <dd>numに５が入る。numのレキシカルスコープは５に保たれる。その状態でaddNumberがリターンによって戻り値で返る。さらにadd5には５が格納されている状態でまた呼ばれているので10が追加され１５になる。</dd>
</dl>
<pre>
<code>
function addNumberFactory(num) {
	function addNumber(value){
		return num + value;
	}
	
	return addNumber;
}

const add5 = addNumberFactory(5)
const result = add5(10);
console.log(result) //expected 15
</code>
</pre>
<h3>即時関数</h3>
<dl>
    <dt>関数定義と同時に一度だけ実行される関数。</dt>
    <dd>実行結果が呼び出し元に返却される。</dd>
    <dd>グループ化させる。</dd>
    <dd>リターンが表示されていたらリターンが返る。</dd>
    <dd>関数のスコープ内でしか使えない値と外側で使う値を明確に分けたいときに使う。</dd>
</dl>
<pre>
<code>
//example 1 
function a(){
	console.log('called')
}

a();
//グループ化とは括弧でかこんであげることを指す。
let sum = (3+ 4) *2
//example 2
//即時関数　（）で囲ってあげる。グループ化する。
(function() {
	console.log('called');;;
})() //無名関数＋即時関数で呼ばれている。

//example 3
let c = (function() {
	let privateVal = 0;
	let publicVal = 10;
	
	function privateFn(){
		console.log('privateFn is called');
	}
	
	function publicFn(){
		console.log('publicFn is called' + privateVal);
	}
	
	console.log('called');
	return  {
		publicVal, 
		publicFn
	};
	
})()

c.publlicFn(); //expected 0
c.publlicFn(); //expected 1
c.publlicFn(); //expected 2

</code>
</pre>
<h3>Varとletの違い。</h3>
<ul>
<li>varは使われていません。</li>
<li>違い1つ目：同じ変数名を再宣言できる。</li>
<li>違い2つ目：スコープ（変数を参照できる範囲の事。）の違い。letは波かっこ内でしかスコープは共有されないが、varは波かっこがあろうともグローバル変数になる。ただしvarには例外があって<strong>関数の場合のみ関数の中からでしかアクセスはできない。</strong>　このことからvarはvarは関数スコープ　letはブロック関数と言われる。</li>
<li>違い3つ目：グローバルオブジェクトの一部になる。</li>
<li>違い4つ目：巻き上げ　hoisting</li>
</ul>
<pre>
<code>
var hello = 'hello';
hello = 'hi'
console.log(hello);


//違い一つ目：同じ変数名を再宣言できる。
var hello = 'hello';
var hello = 'hi';
console.log(hello); //これはエラーにならずにhiが表示される。

//これをletに変えた場合、エラーが起きる。
let hello = 'hello';
let hello = 'hi';
console.log(hello); //error 

//違い2つ目：スコープの違い。 
{
	
	let tomato = 'tomato'
}
console.log(tomato); //スコープの問題でこれはエラーが起きる。

//しかしこれをvarで置き換えると、エラーが起き「ない」。

{
	
	var tomato = 'tomato'
}
console.log(tomato);　//expected tomato varを使うとブロック関係なくグローバルスコープになる。

//違い3つ目：グローバルオブジェクトの一部になる。
var apple = 'apple';
console.log(globalThis); //グローバルオブジェクトにアップルが新しく追加される。

//違い4つ目：巻き上げ　hoisting

console.log(apple); //expected apple 普通ここはletだったらエラーが起きる。
var apple = 'apple";
console.log(apple); 

</code>
</pre>

<h3>グローバルオブジェクト</h3>
<ul>
<li>グローバルオブジェクトを一覧で管理している。</li>
<li>最初にJavascriptエンジンでブラウザで呼んでいる。</li>
<li>globalThis　グローバルオブジェクトが見れる。</li>
<li>組み込み型（ビルトイン）のおかげでいちいち呼び出さなくても使える。</li>
</ul>
<pre>
<code>
//コンソールドットログはどこからきたの？
console.log("hello")

//グローバルオブジェクトを見れる。
conosle.log(globalThis);
</code>
</pre>
<h3>Javascriptのルール　式と文</h3>
<p>Ecmascriptで明確な式と文の定義は別にない。式とはなにか？それは、変数の代入時に右辺に書くものである。例えば　let x = 5;　let y = 8; let z = x + y; この 「x + y」はしきである。この式をJavascriptが読むことを「評価する」と言います。では文とは何か？実行すると何かをすることを指します。厳密の定義は置いて、セミコロンで一文ととらえる。if文やfor文などが文と呼ばれる。文は式になることはできない。さらにここから大事なのが、文を書く場所に式はかける。だからIf文の中にconsole.log();とかも書ける。<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference">（ここで上げている例は一部に過ぎない。）</a> あと意外と重要なのがブロック分です。｛｝ブロック文なしで定義された変数は外側からアクセスすることはできないといことは覚えよう。しかしながらVarをブロックの中で呼ぶと、ブロックの外から呼べてしまう。また関数をブロックの中で定義した場合でもブロックの外から呼ばれる。だから基本的にはブロック内ではletとかconstを使うように推奨されています。またブロック分の中では関数式で記入したほうがいいと思われます。（統一が大事です。）</p>

<h3>useStrictモードとは</h3>
<p>現代のJavascriptが適用される。useStrictを宣言するとルールが制限される。一方で使わないと昔のJavascriptの書き方が適用されるのでルールが緩くなる。サッカーで言うと、VR判定がなくなる。</p>
<h3>primitiveとobjectとは</h3>
<p>Objectはオブジェクト、配列、関数を表す。PrimitiveはInteger, string, boolean, undefined, nullなどを表す。</p>
<ul>
<li>Primitiveの場合　：　不変である。互いに影響を受けない。let x = 8;はメモリに保存される。メモリは電源を切ったら忘れる。</li>
<li>Objectの場合　：　可変である。お互いに影響を受ける。let x = {x:0}はとある特定の住所に保存される。xという番地に数字が間接的に保存される。x=yになった場合もともとの住所は動かさないでxの番地だけを移動する。オブジェクトはいちいち運ばない。アドレスがｘとｙに入っていると思ってください。</li>
<li>Constは再代入を防いでいる。</li>
<li>Constでも値が変わることをmutable　可変と言います。</li>
<li>オブジェクトはmutableである。</li>
<li>逆に変わらないことをimmutable　　primitiveは不変である　と言います。</li>
<li>constのオブジェクト内のプロパティは定義しなおせる。</li>
</ul>

<pre>
<code>
//Primitive型の参照元はそのまま残る。

let a = 'hello';
let b = a;
b = 'bye';
console.log(a,b);

//オブジェクト型の参照先は参照元も変わる。可変。
let c = {
	prop : 'hello'
}

let d = c;
console.log(c,d);

//参照が違うことを示す。番地と住所の話。
const coffee = {
	name: 'Caffe Latte',
}

const coffee3 = {
	name : 'Caffe Latte',
}

console.log(coffee === coffee3); //expected false 


//Constは再代入を防いでいる「だけ」。

const coffee  = {
	name:'Caffe Latte',
}

//example 1 

const coffee = {
	name: 'Caffe Latte',
};

const coffee2 = coffee;
coffee2.name = 'Charamel Machiato';
console.log(coffee); //expected Charamel Machiato Constなのに値が変わってるよね？


//つまり、constのオブジェクト内のプロパティは定義しなおせる。

const b = {
    prop: 'hello'
}
b.prop = 'bye';
console.log(b); //expected bye
</code>
</pre>
<h3>参照と分割代入</h3>
<p>分割代入を使用するとプロパティが持っている参照先がコピーされて新しい変数からの参照が貼られる。</p>
<ul>
<li>プロパティとPrimitiveは違う世界に住んでいる。</li>
</ul>
<pre>
<code>
const a = {
	prop : 0
}

let {prop: b} = a;
console.log(b)

function fn({prop}){
	prop = 1;
	console.log(a, prop);
}

fn(a);
</code>
</pre>
<h3>レキシカル環境(LexicalEnviroment)</h3>
<p>レキシカル環境とはコードを書く場所によって参照できる変数が変わるスコープのことをさします。キーとバリューをセットにしたDBみたいな感じ。オブジェクトである。</p>
<ul>
<li>コードをを記述した時点で決定するため静的スコープとも呼ばれる。</li>
<li>実行中のコードから見た外部スコープのこと</li>
<li>どのようにしてスコープを決定するかの使用のこと</li>
<li>レキシカル環境ではブロックがみつかった場合また更にもう一つのレキシカル環境をつくる。</li>
<li>同じLexical環境内で変数があって呼んだ場合には同じLexical環境内の変数変数が呼び出される。</li>
<li>関数の場合呼び出されたときにLexical環境が作り出される。</li>
<li>関数の場合別々のLexical環境が作り出されるので上書きはされない。</li>
<li>クロージャ：レキシカル環境はアドレスのように指定される。</li>
<li>理論上レキシカル環境は一生残る。</li>
</ul>

<pre>
<code>
let x = 1; // (1)
let a = function( ) {
    console.log( x );
};
let b = function( ) {
    let x  = 2;
    a ( );    // 1

    let b2 = function( ) {
        let x = 3;
        a ( );    // 1
    };
    b2( ); //expected 1
}; 
b( );　//expected 1


let message = "さんこんにちは";

function a( name ){

    let m = name + message;    

    return function ( ){
         console.log( m );
    };
}

let a2 = a( "Taro" );
let a3 = a( "Hanako" ); // 2回呼び出したので変数mが上書きされるはず

a2( );   // Taroさんこんにちは ← 上書きされていない！！
a3( );   // Hanakoさんこんにちは
</code>
</pre>


<h3>クロージャを使ってプライベートを作る方法</h3>
<p>グローバル変数を使っているとバグにはまる。だけどクロージャを使ってプライベートすることがバグにたいして有効的。</p>
<ul>
<li>メソッドをつかって書き換えれなくする。</li>
</ul>
<pre>
<code>

let generatePerson = () => {
	let age = 0;
	return {
		name: () => 'Taro',
		getAge: () => age,
		incrementAge: () => {
			age +=1;
		},
	};
};

const taro = generatePerson('Taro');
console.log(taro.getAge()); //expected 0 
taro.incrementAge();
taro.incrementAge();
console.log(taro.getAge()); //expected 2

const tom = generatePerson('Tom');
tom.incrementAge();
tom.incrementAge();
tom.incrementAge();
console.log(tom.getAge()); // expected 3 ここがレキシカル環境が完全に別れている証拠。

//クロージャを使ってプライベート変数を作る。
//example2

increment();
increment();

function increment(){
	let num = 0; 
	num++;
	console.log(num); //expected 1が三回出力される。numが初期化されているから。
}

//num変数をブロックの外側に持っていくとグローバル変数になって1,2,3と出力されるが。バグが生まれやすくなる。
//じゃあどうするか？
//クロージャを使ってプライベート変数を作る。

function incrementFactory(){ //Factoryは何かを生成するときに用いる。
	let num = 0
	
	function increment(){
		num += 1;
		console.log(num);
	}
	return increment;	
}

increment();

console.log(num); //error numがincrementFactoryの関数の中に入っていることに注目してください。


</code>
</pre>
<h3>クロージャ　動的な関数の生成　</h3>
<p></p>
<ul>
<li>add5にまず値が入る。</li>
<li>次にresultに１０が入る。その時に5はレキシカルスコープに５が残ってる。</li>
<li>そしてリターンのaddNumberにより１５が返される。</li>
</ul>

<pre>
<code>

function addNumberFactory (num){
	function addNumber(value){
		return num + value;
		
	}
	return addNumber;
}

const add5 = addNumberFactory(5); //addNumberFactoryの引数に５が渡される。
const result = addNumberFactory(10); 
console.log(result) //expected 15

</code>
</pre>

<h3>実行コンテキスト</h3>
<p>コンテキスト</p>
<ul>
<li>前後関係、文脈、状況、環境</li>
<li><strong>グローバルコンテキスト</strong>　</li>
<li>実行中のテキスト内の変数関数</li>
<li><strong>関数コンテキスト</strong></li>
<li>実行中のコンテキスト内の変数関数</li>
<li>arguments super this 外部変数</li>
</ul>

<pre>
<code>
//Global context 
let apple = 'mac'; 


function b(){
	//function 関数 context
	console.log(this, arguments, apple);
}
console.log(apple);
b(); 

</code>
</pre>

<h3>コールスタック</h3>
<p>コンテキストの積み重ね</p>
<ul>
<li>どのような経路を通ったのか記録しておくこと。</li>
<li>どのような状態だったのか記録から確認できる。</li>
<li>このようなスタックの仕組みを「後入れ先だし」Last In, First Outという。</li>

</ul>

<pre>
<code>
function a(){
	
}
funciton b(){
	ｂを呼ぶとaを呼ぶ
	a()
	
}
function c(){
	//cを呼ぶbを呼ぶ
	b();
}
c();
</code>
</pre>
<h3>ホイスティング</h3>
<p></p>
<ul>
<li>ブラウザが関数を先に読むようにできている。	</li>
<li>変数の上では呼べない。</li>
<li>このようなことをホイスティングと呼ぶ。</li>
<li>コンテキストが呼ばれるたびにホイスティングが発生する。</li>

</ul>

<pre>
<code>
console.log('apple') //error
let apple = 'Mac';

computer() //expected Hello World
function computer(){
	console.log('Hello World');
}



function a (){
	console.log(c); //error
	let c = 1; //変数宣言の↑では呼べない。
	
	d();
	function d(){
		console.log('d is called.')
	}
	console.log('a is called.')
}

a();

</code>
</pre>



<h3>Object.assignを使ってオブジェクトを拡張する方法</h3>
<p>Object.assignでオブジェクトを結合する。</p>
<ul>
<li>「()」の中の右側が常に優先される。</li>
<li> 無限にとれる。 </li>
<li> スプレッド構文をObject.assignにいれたいときには{}を使う。 </li>
</ul>
<pre>
<code>
const ob1 = {
	a : 1,
}

const ob2 = {
	b: 2,
}

const ob3 = {
	c: 3,
}
Object.assign(ob1,ob2, ob3); //「()」の中の右側が常に優先される。無限にとれる。
console.log(ob1); //expected {a:1, b:2, c:3} 

const coffee = {
	isHot : false,
	charamel : true,
	machiato : true,
	milk : true,
	espresso : true,
}

const newCoffee = Object.assign({}, coffee, {isHot : true}); //スプレッド構文をObject.assignにいれたいときには{}を使う。
console.log(newCoffee === coffee );//expected false


</code>
</pre>
<h3>分割代入</h3>
<p></p>
<ul>
<li>titleを取得してbook.titleにいれて、呼ぶとSpiderManと呼ばれる。</li>
<li>オブジェクトをつけると別名をつけられる。</li>
<li> default値も設定できる。あんま使われない。</li>
<li> 残り全てという書き方もできる。=> 課長編引数　レストパラメーター　...etc</li>
<li> var let も同じように動く。そして関数も動く。</li>
<li> 関数のパラメーターの中にオブジェクトをまんま入れることができる。</li>
<li> 関数を呼び出すときにそのオブジェクトの変数を読んであげる。</li>
</ul>
<pre>
<code>
//example 1



const book = {
	title : 'SpiderMan',
	price : 9.99,
	
}
const title = book.title;　//titleを取得してbook.titleにいれると

console.log(title); //expected SpiderMan


const {title, price} = book; //分割代入はこうする！！！
console.log(title, price ); //expected SpiderMan 9.99 


//example 2
const book = {
	title : 'SpiderMan',
	price : 9.99,	
}


const {title: booktitle, price} = book; //ここでオブジェクトに別名をつけてる。
console.log(booktitle, price);　//expected SpiderMan 9.99 


//example 3

const book = {
	title : 'SpiderMan',
	price : 9.99,	
	author : { 
		firstName : 'Imanishi',
		lastName :  'Tsuyoshi',
	},
}


const {title: booktitle, price, author : {firstName, lastName}} = book; //ここでオブジェクトに別名をつけてる。
console.log(booktitle, price, firstName, lastName);　//expected SpiderMan 9.99 Imanishi Tsuyoshi

//example4

const book = {
	title : 'SpiderMan',
	price : 9.99,	
	author : { 
		firstName : 'Imanishi',
		lastName :  'Tsuyoshi',
	},
	isbn : 2345874,
	description : 'A man fights for the revenge.',
}


const aboutBook = ({
title: booktitle, 
price,
author : {firstName, lastName},
publisher:pub = 'Sanakaku Shikaku', //デフォルト値が設定できる　bookの方にはpublisherは含まれていません。
...etc　//スプレッド構文を追加できる。isbnとdescriptionはaboutBookには含まれていないことに注目。

})=> {
	console.log(booktitle, price, firstName, lastName, pub, etc);　
};

aboutBook(book); 
</code>
</pre>

<h3> in演算子を利用してプロパティの有無を調べる。</h3>
<p>特定のプロパティがあればTrueなければFalseを返す。</p>
<ul>
<li>「book.title !== undefined」と 「'title' in book」 は違う。</li>
<li>「book.title !== undefined」の場合呼び出しても表示されない。タイトルはないってことになる。</li>
<li>「'title' in book」の場合、タイトルはあるってことになる。でもundefinedは呼び出されない。</li>

</ul>
<pre>
<code>
//example 1
const book ={
	title : 'the begginer couse of Javascript',
}

book.title = undefined //ここでundefinedにすると
　
if(book.title !== undefined){ //ここは表示されない。
	console.log(book.title); // the begginer couse of Javascript
	console.log('title' in book); //expected true
}

//example 2 
const book ={
	title :'the begginer couse of Javascript',
}

book.title = undefined;

if('title' in book ) {
	console.log(book.title);//expected the begginer couse of Javascript
	console.log('title' in book); //expected true 
}
</code>
</pre>


<h3>配列とforeachメソッド</h3>
	<pre>
		<code>
const animals = ["Lion", "Giraff", "Gorilla", "Dog", "Snake", "Rabbit"];

//フォー文をつかったときと同じ結果がでる。簡略も可能である。
animals.forEach(function(v, i, animals) {
console.log(v)
})
//アロー関数で書き直すと。。。
animals.forEach((v, i, animals)　=> {
console.log(v)
});
//第二第三引数が必要ない場合は、かっこ省略と波かっこも省略できる。
//できるだけ変数をへらすことができる。＝バグが少なくなる。軽くなる。
animals.forEach(v　=>console.log(v));


for(let i = 0; i &lt; animals.length; i++) { const v=animals[i]; console.log(v); }

let array = ['apple', 'banana', 'grape'];
array = [1,2,3];
array = [1, 'apple', true, array];
array = ['apple', 'banana', 'grape'];
console.log(array[0]) //expected apple

array.push("pinapple");
console.log('array');

 </code>
	</pre>
	<h3>オブジェクト キーとバリューが並んでいる塊。</h3>
	<p>キーとバリューをセットでプロパティと呼ぶこともある。</p>

	<pre>
		<code>
	//object
const coffee =  {
	//name property
	name : 'chocolate Mocha", 
	size : 350,
	isHot: true,
	toppings : ['Cinnamon', 'Caramel'],
	nutritions : {
		calories : 430,
		sugar : 53,
		caffeine: 100,
	},
};

console.log(coffee,size) // expected 350
coffee.isHot = false;
coffee.barista = 'Tom'

const coffee = {
    name: "Matcha Latte",
    size: "tall",
    price: "450",
    tempature: "hot",
    addSweet: true,
};

coffee.addSweet
//expected true
coffee.name
//expected 'Matcha Latte'
coffee.price
//expected '450'
 </code>
	</pre>
	<h3>Optional　Chaining　オプショナルチェーン。</h3>
	<p>「.」の手前には「?」をつけることができる。</p>
<ul>
<li>オプショナルチェーンとは　：「？」の左側がnullかundefinedならばすぐにnullかundefinedを返す。</li>
<li>？の右側は無視する。</li>
<li>？の左側の変数がない場合はerrorになる。</li>
</ul>
<pre>
<code>
let user = undefined
user.address //expected error

user?.address; //errorは出なくなる。
 </code>
</pre>

<!--	<h3>フォームの入力内容を取得する。</h3>
	<section>
		<form action="#" id="form">
			<input type="text" name="word">
			<input type="submit" value="search">
		</form>
		<p id="output3">
		</p>
	</section>



	<section>
		<p>次のワールドカップまで</p>
		<p class="timer"> <span id="day"></span>日<span id="hour"></span>時間<span id="min"></span>分<span id="sec"></span>秒
		</p>
	</section>
 -->
 
 <h3>null vs undefined</h3>
	<p>nullは意図的に何も値を入れていないときに使う。Undefiinedは意図せず値が入っていなかったときなどにUndefiinedと返す。</p>
	
	<h3>動的型付け言語</h3>
	<p>動的型付け言語の場合には、途中で変数のデータ型が変わることも許容されます。つまり、数値型の変数に文字列を代入することもできるのです。宣言時にNumber（数値）であった変数ですが、文字列を代入してもエラーにはなりません。文字列が代入されたタイミングでデータ型がString（文字列）に変換されるためです。このように、JavaScriptではデータ型が自動的に付与されるため、データ型を強く意識する必要がありません。他の言語では、例えば数値型の変数に文字列を入れるとエラーになってしまいますが、JavaScriptではそれが起こりません。</p>
<h3> Typeof演算子</h3>
	<pre>
		<code>
typeof "Hello"
'string'
typeof 3
'number'
typeof true
'boolean'
typeof [1,2,3]
'object'
typeof null
'object'
typeof undefined
'undefined'
typeof {name:"Tom"}
'object'

		</code>
	</pre>
<h3>While文</h3>
	<pre>
		<code>
 
 let count = 0;
 
 while (count &lt; 10){
	console.log(count);
	count += 1;
}

//expected 0,1,2,3,4....

		</code>
	</pre>
<h3>do While文</h3>
	<pre>
		<code>
 上記の例と下記の例を見比べてみて
 
 
 let count = 100;
 while(count > 10) {
	console.log('while Counting...:' count);
	count += 1;
}
 
 let count = 0;
 
 do {
	console.log("do while Counting..."count);
	count += 1;
	
}while(count &lt; 10);

//expected 0,1,2,3,4....

		</code>
	</pre>
	<h3> FOR文</h3>
	<pre>
		<code>
		
//for(;;) ⇐の意味は三つ式を取りますよという意味。

const secondexample = [122,444,556,634];
//iは添え字という意味合いがある。ofの時は使わない。
//ofでは添え字が渡ってくる。
for (let i of secondexample){
console.log(i);
}


//inでは値がわたってくる。
const arry = [1,3,5,6,7,9]
for (let i in arry) {
console.log(i); //output 1,3,5,6,7,9
}


/*ちなみにletはこうも書ける。
let a = 1, b = 2;
よってfor文ではこう書ける。*/

for (
	let pumbpkinCount = 0, i = 0;
	pumbpkinCount &lt; 10;
	pumbpkinCount +=1, i += 1
) {
	console.log(pumbpkinCount);
}

for (let i=0; i&lt; todos.length; i++){ console.log(todos[i]);　 <br>
	//output //*completed: true id: 1 title: "go to a movie theate

	completed: true
	id:2 ..続く
	*/
	console.log(todos[i].title);　
	//go to a movie theater
	//go shopping
	//having dinner

	}


const fruits = ["apple", "grape", "banana"];


//拡張For文：一般的にはconstを使う。letも使える。配列の時のみに使う。
for (const fruit of fruits) {
	console.log(fruit)
}
//inは一般的にobjectに使う。


const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

for (const customer in coffee) {
	console.log(customer)
}


		</code>
	</pre>

	<h3>break文</h3>
	<pre>
		<code>

const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

for (const customer in coffee) {
	console.log(customer);
	console.log(coffee[customer]);
	
	if(customer === 'size'){
		console.log('break!');
		break;　//ここで動きが止まる。
	}
}
		</code>
	</pre>
	<h3>continue文</h3>
	<pre>
		<code>

const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

for (const customer in coffee) {
	if(customer === 'size'){
		console.log('continue...');
		continue;　//ここからスキップが始まる。
	}
	console.log(customer);
	console.log(coffee[customer]);
	
}
		</code>
	</pre>
	<h3>ラベル文 あんまり使われない。</h3>
	<pre>
		<code>
ラベル文はbreak文とcontinue文と一緒に使う。
hello:{}


const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

coffeeLabel:if (true){
 for (const customer in coffee) {
	if(customer === 'size'){
		console.log('continue...');
		break coffeeLabel;
	}
	console.log(customer);
	console.log(coffee[customer]);
	
}
	console.log("Do you wanna have another a cup of coffee?")
	
} // expected name caffe latte continue... 
//↑の場合"Do you wanna have another a cup of coffee?"は出力されず、If文の外側に移動することになる。ラベル文が内側と外側で同じ名前と定義されている場合はエラーになる。ただし、外側と外側で同じ名前をもつラベル文の場合はエラーにはならない。なぜなら、全く違う変数とみなされるから。またノートすると、ラベル文は関数に対しては使えない。
		</code>
	</pre>
<h3>if文　演算子</h3>
	<pre>
		<code>
//二つの値が一致するかどうか？」の時にIf文を使う。
//等値演算子
//＝＝　の時は左辺と右辺の方は気にしないでデータが等しいかどうかを決める
//同値演算子
//＝＝＝の時は左辺と右辺のデータの方も含めて等しいかどうかを決める。
同じであればtrueを返す

const number = 10;

if (number){
console.log(" Yes"); 
} else if(true) { 
	console.log("No"); 
	} else { 
		console.log("error"); 
		}

 
 let ok = false;
 let maybeok = false;
  //↓真偽地	
if(ok) {
	console.log('ok');
} else if (maybeok) {
	console.log('maybe okay');
	} else { //falseの場合のみ
	console.log('It is not ok ! No!');
}


ok = 1 === 1;
ok = "hello" === "hello";
ok = 1 !== 2;
ok = 1 == 2; 

ok = 1 > 0; //expected true　大なり
ok = 1 &lt; 0; //exxpected false 小なり
ok = "a" &lt; "b"; // expected true
ok = "A" &lt; "a"; //expected true
console.log(ok);


//falsy false として扱われる値
false
0
-0
On
null
undefined
NaN

/************/
//論理演算子
ok = false && true;
ok = false || false;
//Truethy Falseyの場合はどうなるのか？
ok = 'hello' && 'hi'; //アンド演算子は、右側がtruethyであれば、右側を返す。
ok = '' || 'hi'; //or演算子は左側がtruethyであれば、左側を返す。


const x = 15;
ok = x === 10 || (x > 12 && userName);

if(ok) {
	console.log("ok");
} else {
	console.log('No');
}
console.log(ok); 

ok = !true //「!」は反対の意味を表す。expected false 
ok = !'hello' // expected false 
ok = !x; // expected false 
ok = !!x; //expected true これは！！ふたつだから。
console.log(ok); 
		 </code>
	</pre>
	
	<h3>try catch　finally文</h3>
	<pre>
		<code>
try {
	console.log('do');
} catch {
	console.log('catch an error');
}
console.log('done');

//expected do done

try {
	//変数チョコレートを適当に入れる。
	console.log(chocolate);
} catch {
	console.log('catch an error');
}
console.log('done');　
//expected catch an error done


//もう少し複雑にしてみるとキャッチの中にさらにトライを入れることができる。
try {
	console.log(chocolate);
} catch {
	console.log('catch an error');
	
	try {
		console.log(chocolate)
	} catch {
		console.log('error occured')
	}
} 
console.log('done');　
//expected catch an error error occured done


//finallyは必ず出力される

try {
	console.log(chocolate);
} catch {
	console.log('catch an error');
	//どんな理由であれファイナリーは実行される。優先順位はめちゃくちゃ高い。
}  finally {  
	console.log('done...')
} 
//expected catch an error done...
		</code>
	</pre>
	<h3>三項演算子</h3>
	<a href="https://jsprimer.net/basic/operator/#ternary-operator">詳しくはこちらを。</a>
<pre>
	<code>

const ok  = "hello"
ok = ok ? 'OK' : 'NO';

console.log(ok);

	</code>
</pre>
	<h3>switch文</h3>
<pre>
	<code>
例えばこのようなコードがあったとする。
if(vegetable === "tomato") {
	console.log('tomato is red');
} else if (vegetable === "pumpkin"){
	console.log("pumpkin miso soup.")
} else if (vegetable === "onion"){
	console.log("onion is good with steak.")
}

switch文で書いてみると・・・。
switch (vegetable) {
	case 'tomato':
		console.log('tomato is red');
		break;
	case 'pumpkin'
		console.log("pumpkin miso soup.");
		break;
	case 'onion'
		console.log("onion is good with steak.");
		break;
	default: 
		console.log('not found');
}

switchとブロック分を使ってみると・・。
switch (vegetable) {	{
	case 'tomato':
		const message = 'tomato is red'	
		console.log(message);
		break;
}
	{
		case 'pumpkin'
		const message = "pumpkin miso soup."
		console.log(message);
		break;
	}
	
	{
		case 'onion'
		const message = "onion is good with steak."
		console.log(message);
		break;
	}
	{
		default: 
		console.log('not found');
	}
}

	</code>
</pre>
	<h3>Global Scope Local Scope </h3>
	<p>スコープ とは、「 変数 が スクリプト の 中 の どの 場所 から 参照 できる か」 を 決める 概念 です。 JavaScript の スコープ は、 以下 の 2 つ に 分類 でき ます。 ・スクリプト
		全体 から
		参照 できる グローバル スコープ ・定義 さ れ た 関数 の 中 で のみ 参照 できる ローカル スコープ</p>
<pre>
	<code>
const newValue = 'Hello';	変数をつくって関数の中で呼んでみる。
		
function add(num1, num2){
	console.log(newValue); //これは呼び出せる。
	const value = num1 + num2;　//関数のなかに変数を作る。
	return value;
}
console.log(value)//これは呼び出せない。
const returnedValue = add(2,3); 

************
関数の外側からは変数にアクセスはできない
************
スコープがすべての場所、ここでいう、const newValue = 'Hello'はグローバルスコープ
またはグローバル変数と呼ぶ。

const returnedValue = add(2,3); 
</code>
</pre>
	<p>ローカル変数は関数の先頭で宣言することを心がける。なぜならば、<a href="https://developer.mozilla.org/ja/docs/Glossary/Hoisting">変数</a>の巻き上げをふせぐため。</p>
<pre>
<code>
/*関数の中だけしか扱えないようなconst value = num1 + num2;
変数をローカルスコープまたはローカル関数と呼ぶ。または関数スコープとも呼ぶ。　
*************/
//関数の内側と外側に同じキーの変数があった場合、優先して呼ばれるのは内側の変数。
/*****************/
//これをshadowing　シャドウウィングと呼ぶ
const newValue = 'Hello';	//変数をつくって関数の中で呼んでみる。
		
function add(num1, num2){
	console.log(newValue); //これは呼び出せる。
	const newValue = num1 + num2;　//関数のなかに変数を作る。
	return value;
}
</code>
</pre>
	<pre>
		<code>
/*ファンクションコンストラクターの配下の変数はその宣言場所にかかわらず、
常にグローバルスコープとみなされる*/
var scope = 'Global Variable';  
function checkScope() { 
var scope = 'Local Variable';  
var func = function() { 
	return scope; 
	};  
console. log( func()); //結果： Local Variable 
var func2 = new Function(' return scope;');  
console. log( func2()); // 結果： Global Variable }

		</code>
	</pre>

<h2>関数　Function</h2>
	<h3>関数Function アロー関数</h3>
	<ul>
	<li>関数はオブジェクトに過ぎない。</li>
	</ul>
	<pre>
	<code>
function add(a,b){
	return a + b;
}

console.log(add);
console.log(add.name);
console.log(add.length);
関数がオブジェクトなら代入できるよね？
const newAdd = add;
console.log(newAdd(3,4)); //expected 7 
	</code>
	</pre>

<h3>関数式</h3>
<p>関数は静的な構造を宣言する。</p>
<ul>
<li>関数を定義するときには2つの方法がある。</li>
<li>関数の宣言文をつかって関数を生み出す。</li>
<li>関数式を使って関数を生み出す。</li>
</ul>
	<pre>
	<code>
//名前付き関数式
let sayHi  = function hi(){
	return 'Hi';
}

console.log(sayHi()); //expected Hi

//名前がついていない関数をAnonymusFunction無名関数という。
sayHi = function (){};
console.log(sayHi());

console.log("Triangle area:" + getTriangle(5,2));

function getTriangle(base, height){
return base * height/2;
}
//上記の例はエラーとはならない。ファンクション命令はコードを
//解析・コンパイルするタイミングで関数を登録している。

console.log("Triangle area:" + getTriangle(5,2));

var getTriangle = function(base, height){
return base * height /2;
}

//上記の例はエラー。ファンクション命令tとは異なり、
//関数リテラル・ファンクションコンストラクターは実行時（代入時）に評価される。
//この場合だと、呼び出し元のコードよりも前に記述しなければならない。
//アロー関数 二行以上の場合は波かっこが必要。一行の時は波かっこ消去可能。

const hello = (name, age) => {
console.log('hello' + name + age)
console.log('hello' + name + age)
}
hello("Erran", 27);
	</code>
	</pre>
<p>関数宣言文VS関数式どっちで宣言したらいいのか？</p>
<ul>
<li>関数は巻き上げられる。関数は一番初めに読み込まれるため、戻り値の下にあろうが、呼び出される。</li>
<li>関数式は巻き上げられない。つまり関数宣言した前では呼び出せない。</li>
<li>一方関数宣言文は何処でも呼ぶことができるのと視覚的に関数とわかりやすい。</li>
<li>プロジェクトで統一することが大事。関数式を使うといいかも・。</li>
</ul>
	<pre>
		<code>
//普通のFunction
//function hello(name) {
//console.log('hello' + name);
//}

//hello("Tom");

//普通のFunction
function getTriangle (base, height) {
return base * height/2;
}

console.log("Triangle area :" getTriangle(5,2));


function add(){
    console.log(2+2);
    }
  add(); //呼び出し方
//expected 4
    
//パラメーターと引数。
  
//パラメーター
 function add(num1, num2){
	
	console.log( num1 + num2);
}
//引数（argument）
add(5,3);

//expected 8

//return文
//return文のあとの文法はすべて無視される。

function add(num1, num2){
	return num1 + num2;
}

const returnedValue = add(2,3);
console.log(returnedValue);
		</code>
	</pre>

<p>関数とメソッドの違い。</p>
<ul>
<li>キーとバリューセットをプロパティと呼ぶ。</li>
<li>そのため、sayHiはプロパティである。</li>
<li>またはsayHiメソッドと言う。</li>
</ul>
<pre>
<code>

const person = {
	name : 'Taro',
//メソッド
	sayHi: function () {
		return 'hi';
	}
}
</code>
</pre>

<h3>アロー関数 ３つの特徴</h3>
<ul>
<li>functionもreturnも略せる。</li>
<li> 無名関数の置き換えになる。無名関数の別の書き方がアロー関数。</li>
<li> だから関数に名前はいらない。</li>
<li>1. 一つに式をリターンする場合波かっこと且つリターンを省略できる。</li>
<li>2. パラメータが一つの場合、パラメータの〇括弧を省略できる。ただパラメータが一つの場合のみです。</li>
<li>3. this arguments new prototypeはアロー関数では使えない。</li>
<li> アロー関数にオブジェクトはつけられない。式と認識するから。もしオブジェクトを入れたい場合は（）をつけてやる。</li>
</ul>
	<pre>
		<code>
//無名関数式
sayHi = function (name) {
	return `hi ${name}!`;
}
//アロー関数
sayHi = (name) => {
	return `Hi ${name}`;
}

//波かっこを消して且つリターンも省略
sayHi = (name) => `Hi ${name}`;

// アロー関数にオブジェクトはつけられない。
sayHi = (name) => {
	name: name;
}
じゃあどうするか？()をつけてやると式と認識する。
sayHi = (name) => ({
	name: name;
})

//アロー関数
var getTriangle = (base, height) => base * height /2;
console.log("Traiangle area:' getTriangle(5,2);// expected 5

//アロー関数はFor文でよく使われる。

const numbers = [1,2,3,4,5,6,7,8];

numbers.forEach(function(value) {
console.log(value);
}) //output 1,2,3,4,5,6,7,8

numbers.forEach(value => console.log(value))//output 1,2,3,4,5,6,7,8
		</code>
	</pre>

<p>Callback function (コールバック関数)</p>
<ul>
<li>
コールバック関数とは、引数として他の関数に渡され、
外側の関数の中で呼び出されて、何らかのルーチンやアクションを完了させる関数のことです。
</li>
<li>引数に関数は渡せる。頻繁度高く使われるので覚えよう。</li>
</ul>
	<pre>
		<code>
function doSomething(a, b, callback) {
const result = callback(a,b);
console.log(result);
}

function multiple(a,b) {
return a * b;
}

doSomething(8, 9, multiple);

//引数に関数は渡せる。

let subtract = (a, b, callback) => {
	let result = a - b;
	callback(result);
}

subtract(10,3, (result) => {
	console.log(result); //expected 7
});

subtract(19,4,(result) => {
	alert(result); //expected 15
});

//example 2
function bye(){
	console.log('bye');
}

function hi(name){
	console.log('Hi' + name);
}

function fn(callback){
	callback('Taro');
}

fn(bye); //expected bye
fn(hi); //expected Hi Taro
fn(function(name) {
	console.log('hello' + name);
})//expected  hello Taro

		</code>


	</pre>
<p>コールバック関数例２</p>
	<pre>
		<code>
const lists = ["number1", "number2", "number3"];

function forEach(lists, callback) {
for(let i = 0; i &lt; lists.length; i++){ callback(lists[i])
	}
	}
function showLists(list) { console.log(list);}
function addList(list) { list="This is " + list showLists(list); }
 forEach(lists, addList);
 // This is number1 .... continue... 
//関数を定義せずにforEachを使ってそのまま書くこともできる。 forEach(lists, function(list) 
list="This is " + list; showLists(list); }); 
//output // This is number1 .... continue...
		</code>
	</pre>
	
<h3>コールバック関数とthis</h3>
<p>オブジェクトのメソッドとして実行される場合thisは呼び出し元オブジェクトをさす。関数として実行される場合thisはグローバルオブジェクトを指す。</p>
<ul>
<li>bindによって'this'や引数を固定した新しい関数を作成。</li>
<li>bindをつかってthisのオブジェクトまたは引数を固定することができる。</li>
</ul>

<pre>
<code>

window.name = 'John';

const person = {
	name : 'Tom',
	hello : function (){
		console.log('Hello' + this.name);
	}
}

person.hello(); //expected HelloTom


function fn(ref){
	ref();
}

fn(person.hello); //expected HelloJohn

//bindをつかってthisのオブジェクトまたは引数を固定することができる。
const helloTom = person.hello.bind(person);

fn(helloTom); //expected helloTom

function a(name) {
	console.log('hello' + name);
}

const b = a.bind(null, 'Tim');

b('Tom');
</code>
</pre>
<h3>call apply と　this</h3>
<p>bindはthisや引数の参照先を変更する。使用時点で実行はしない。call apply 'this'や引数の参照先を変更。同時に関数を実行する。</p>
<ul>
<li>apply call は関数の仮引数を定義することができる。</li>

</ul>

<pre>
<code>
function a(name, name1){
	console.log('hello' + name + '' + name1);
}

const tim = {name: 'Tim'};

const b = a.bind(tim);

b();

a.apply(tim, ['Tim', 'Bob']); //applyは配列で呼び出す。
a.call(tim, 'Tim', 'Bob');

</code>
</pre>
<h2>関数とオブジェクト　Part２</h2>
<h3>コンストラクター関数</h3>
<p>新しくオブジェクトを作成するための雛形となる関数。</p>
<ul>
<li>newで作成したオブジェクトをインスタンスという。</li>
<li>newでオブジェクトを作成することをインスタンス化という。</li>
<li>オブジェクトを大量に生産したい場合にはnew演算子とコンストラクターを使ったオブジェクトの生成は大変有効的である。</li>
<li>テンプレート化されたオブジェクトを生成するためにはコンストラクター関数が使われる。</li>
<li>new演算子をつかってオブジェクトを生成することをインスタンス化するという。</li>
</ul>
<pre>
<code>

function Person(name, age){
	this.name = name;
	this.age = age;
}

const bob = new Person('Bob', 18);
const tom = new Person('Tom', 18);
const Sum = new Person('Sum', 18);


</code>
</pre>
<h3>プロトタイプ</h3>
<p>オブジェクトに存在する特別なプロパティー。コンストラクター関数と合わせて使用する。</p>
<ul>
<li>インスタンス化した際にはprototypeの参照が__proto__にコピーされる。</li>
<li>プロトタイプを使わないとhelloというメソッドを随時追加することになる。=>メモリ消費する。</li>
<li>コンストラクター関数を作ってプロトタイプを使うと、いちいちhello関数を定義しなくてよくなる。=>メモリに優しい。</li>

</ul>
<pre>
<code>

function Person(name, age){
	this.name = name;
	this.age = age;
}

Person.prototype.hello = function () {
	console.log('hello' + this.name)
}
const bob = new Person('Bob', 18);
const tom = new Person('Tom', 18);
const Sum = new Person('Sum', 18);

bob.hello();

</code>
</pre>
<h3>new演算子</h3>
<p>コンストラクター関数からインスタンスを作成するために使用する演算子</p>
<ul>
<li>コンストラクター関数の戻り値がオブジェクトの場合、コンストラクターが返すリターンのオブジェクトを新しいオブジェクトとして呼び出し元に返す。</li>
<li>コンストラクター関数の戻り値がオブジェクト以外の場合、コンストラクターのプロパティの__prototype__にコピーされる。</li>
<li>スーパーは親のメソッドを呼ぶことができる。</li>
</ul>
<pre>
<code>

function F(a,b){
	this.a = a;
	this.b = b;
	return {};
}


</code>
</pre>
<h3>instance of</h3>
<p>どのコンストラクターから生成されたオブジェクトかを確認する。</p>
<ul>
<li>どのようなときに使うか？</li>
<li>配列かオブジェクトかを判定する場合に条件分岐として使う。</li>
</ul>
<pre>
<code>
function F(a,b) {
	this.a = a;
	this.b = b
	return {a:1}
}

F.prototype.c = function (){};

const instance = new F(1,2);
console.log(instance instanceof F) //expected false
console.log(instance instanceof Object ); //expected true
console.log(instance.__proto__ === F.prototype)

function fn(arg){
	if(arg instanceof Array){
		
	arg.push('value');
	}else {
		
	arg['key'] = 'value';
	}
	console.log(arg)
}

//fn() //オブジェクトの時はオブジェクトを追加
fn([]) //配列の時は配列で追加


</code>
</pre>
<h3>関数コンストラクター</h3>
<p>関数は実行可能なオブジェクトである。</p>
<ul>
<li>''で関数のBODY部分を表す。</li>
<li>関数はオブジェクトである。</li>
<li>関数コンストラクターで作られたインスタンス関数は関数オブジェクトである。</li>
<li>関数宣言と関数コンストラクターは明確に使い分ける必要がある。</li>
<li>関数コンストラクターは一般的には脆弱性の問題になるため使わないようにしましょう。</li>
</ul>
<pre>
<code>
//関数コンストラクター　''で関数のBODY部分を表す。
const fn1 = new Function('a', 'b', 'return a + b'); 

const result = fn1(2,4);

console.log(result);

function fn2(a,b) {
	retunr a + b;
}

console.log(fn2 instacneof Function) //expected True

//無名関数で生成されたオブジェクト
const obj = new function(){
	this.a = 0;
}
//無名関数から生成したオブジェクトインスタンス　→オブジェクトリテラルで囲まれる。
const fn3 = new Function ('return;');　
const obj3 = new fn3('this.a = 0;');　//ここで関数に入れてあげる。と
//関数からインスタンス化されたオブジェクトになる。
console.log(obj, fn3);
</code>
</pre>
<h3>プロトタイプチェーン hasOwnProperty In </h3>
<p>プロトタイプの多重形成をプロトタイプチェーンと言う。</p>
<ul>
<li>__prototype__が多態層で重なっている事をPrototypeChainと表現する。</li>
<li>Personのクラスが呼び出される。しかし、Personくらすをコメントアウトすると、Objectクラスが呼び出される。</li>	
<li>多重形成されたプロトタイプでは呼び出し先の優先順位が決まっている。</li>
<li>hasOwnPropertyで自分自身のオブジェクトのプロパティとして引数で与えられた名前が存在するかをbookeanで確認できる。</li>
<li>inは文字列のプロパティまたはメソッドが格納されているか調べることができる。</li>
<li>inを使った場合プロトタイプチェーンを含めて名前のメソッドが存在するかどうか遡って調べていく。</li>
</ul>

<pre>
<code>
function Person(name, age) {
	this.name = name;
	this.age = age;
}

Person.prototype.hello = function(){
	console.log('Hello  ' + this.name + ', you are '　+ this. age );
}
Object.prototype.hello = function(){
	console.log('Hello  ' + this.name + ', you are '　+ this. age );
}

const bob = new Person('Bob', 18);
bob.hello();

const result = bob.hasOwnProperty('name', 'age');
console.log(result); //expected true
console.log('name' in bob); //expected true 文字列のプロパティまたはメソッドが格納されているか調べる
console.log('hasOwnProperty' in bob); //expected true プロトタイプチェーンを含めて名前のメソッドが存在するかどうか調べる。
</code>
</pre>
<h3>デフォルトパラメータはこう使う</h3>	
<ul>
<li>
もし戻り値を返さなかったらどうなるの？
</li>
<li>デフォルト値を設定できる。</li>
<li>戻り値にUndefinedもいれることができる。</li>
<li>UndefinedだけがDefaut値に変換される。</li>
<li>引数が複数あった場合デフォルト値はデフォルトパラメータの最後に設定する。</li>
<li>こちらは例を見てください。デフォルト値が二つ以上あった場合はB=Aともできる。messageにnameを代入することができる。</li>
<li>引数を入れすぎた場合は無視される。</li>
</ul>
<pre>
<code>

sayHi = (name) => `Hi ${name}!`; 

console.log(sayHi('Aoi'));//expected Hi Aoi!

//もし戻り値を渡さなかったら？
sayHi = (name) => `Hi ${name}!`; 

console.log(sayHi());　//undefined 


//何も戻り値がなかった場合にデフォルト値を設定できる。
sayHi = (name = 'User') => `Hi ${name}!`; 

console.log(sayHi());　//expected Hi User!

//戻り値にUndefinedも入れることができる。
sayHi = (name = 'User') => `Hi ${name}!`; 

console.log(sayHi(undefined));　//expected Hi User!

//引数が複数あった場合デフォルト値はデフォルトパラメータの最後に設定する。
sayHi = (name, message=' how are you?') => `Hi ${name} ${message}`; 

console.log(sayHi('Rin'));　// Hi Rin how are you?

//デフォルト値が二つ以上あった場合はB=Aともできる。messageにnameを代入
sayHi = (name, message='${name}') => `Hi ${name} `; 

console.log(sayHi('Rin'));　// Hi Rin 

sayHi = (name, message='${name}') => `Hi ${message}`; 

console.log(sayHi('Rin', 'how are you?'));　// Hi how are you?
</code>
</pre>

<h3>プロトタイプ継承</h3>
<p>別のコンストラクター関数のプロトタイプを受け継いで、機能を流用できるようにすること。</p>
<p>継承　：　別のコンストラクター関数を受け継ぐこと。</p>
<ul>
<li>複数個所に同じコードを書くのは効率的ではない。</li>
<li></li>
<li></li>
</ul>
<pre>
<code>
function Person(name, age){
	this.name = name;
	this.age = age;
}

Person.prototype.hello = function(){
	console.log('hello' + this.name);
}


function Japanese (name, age){
	Person.call(this, name, age, gender);
	//Japaneseクラスだけに特定のプロパティを追加することもできる。
	this.gender = gender 
}

//上書きが可能になる。
/*Person.prototype.hello = function(){
	console.log('hello' + this.name);
}*/

//プロトタイプ継承
Japanese.prototype = Object.create(Person.prototype);
//上書きをしてあげる。必ずプロトタイプ継承した後に上書きすること。
Japanese.prototype.hello = function(){
	console.log('Konnichiwa ' + this.name);
}

Japanese.prototype.bye = function(){
	console.log('Matane! ' + this.name);
}

const taro = new Japanese('Taro', 32, 'Male');

console.log(taro); // Japaneseだけに性別プロパティが入っている。
taro.hello(); //expected helloTaro
taro.bye();
</code>
</pre>

<h3>クラス</h3>
<p>コンストラクター関数をクラス表記で書けるようにしたもの。シンタックスシュガーという。</p>
<ul>
<li></li>
</ul>
<pre>
<code>
class Person {
	constructor(name, age) {
		this.name = name;
		this.age = age;
	}
	
	hello(){
		console.log('hello ' + this.name);
	}
}

const bob = new Person('Bob', 23);
console.log(bob);

/*
function Person(name, age){
	this.name = name;
	this.age = age;
}

Person.prototype.hello = function(){
	console.log('hello' + this.name);
}
*/
</code>
</pre>
<h3>プロトタイプ継承</h3>
<ul>
<li>extendsをつかって継承する。</li>
<li>superはコンストラクター内の一番初めに呼ばなければならない。</li>
</ul>
<pre>
<code>
class Person {
	constructor(name, age) {
		this.name = name;
		this.age = age;
	}
	
	hello(){
		console.log('hello ' + this.name);
	}
}

class Japanese extends Person {
	constructor (name, age,gender){
	super(name, age);
	this.gender = gender;
} 
	
	bye(){
	console.log('Matane! ' + this.name);
}
	hello(){
	// super.hello(); これを実行するとPersonクラスのhelloメソッドを呼び出すことになる。
	console.log('Konnichiwa ' + this.name);
}

	
}
 const taro = new Japanese('Taro', 32, 'Male');

console.log(taro); // Japaneseだけに性別プロパティが入っている。
taro.hello(); //expected helloTaro
taro.bye();
</code>
</pre>
<h3>プロパティとディスクリプター</h3>
<ul>
<li>value　値</li>
<li>configurable　設定変更可能性</li>
<li>enumerable　列挙可能性</li>
<li>writable 値の変更可能性</li>
</ul>
<pre>
<code>
const obj = {prop : 0};

const descriptor = Object.getOwnPropertyDescriptor('prop', 0);
/ * 
Object.defineProperty(obj, 'prop', {
		value: 0;
		writable: true //writableだけtrueにすることができる。
		configurable : true
})

definePropertyを使うことでconfigurable,enumerable,writableがすべてfalseになる。
*/

/*
definePropertyを使ってwritableをtrueにしたのでここでobjectが追加できる。

obj.prop = 1;
console.log(obj.prop); //expected value : 1 


delete obj.prop // configurableをtrueにすることで消去可能になる。
*/

console.log(descriptor); //expected configurable: false enumerable: true value:"p" writable: true
</code>
</pre>
<h3>ゲッターセッター</h3>
<ul>
<li>definePropertyを使ってゲッターセッターを使う。</li>
<li>何らかの処理をはさむ際にゲッターセッターを使う。</li>
</ul>
<pre>
<code>
function Person1(name, age) {
	this._name = name;
	this._age = age;
}

Object.defineProperty(Person1.prototype, 'name', {
	get: function(){
		console.log('Hello');
		return this._name;
	},
	set: function(val){
		//valueをセットする。
		this._name = val;
	}
});

const p1 = new Person1('Bob', 23);
console.log(p1.name); //expected Bob


/*
クラスでゲッターセッターを使うと

class Person2 {
	constructor(name, age){
		this._name = name;
		this._age = age;
	}
	//getter
	get name(){
		console.log('hello');
		return this._name;
	}
	//setter
	set name(val) {
		this._name = val;
	}
	//static method
	static hello(){
		console.log('hello')
	}
}

Person2.hello()
*/
</code>
</pre>
<h3>レストパラメーターで無限個の引数を扱う方法</h3>
<ul>
<li>
「...」レストパラメーターを使うと数を無限個引き受けられる。
</li>
<li>
「...」レストパラメーターを使うときは必ずパラメータの最後に書く。
</li>
<li>
「...」レストパラメーターを使うときは必ず括弧をつける。
</li>
<li>
「...」レストパラメーター以外にもargumentsがあるがそれは使用しないようにしましょう。
</li>
</ul>
<pre>
<code>
普通に足していく
let sum = (a,b,c) => {
	return a + b + c;
}

console.log(sum(23,5,6)); //expected 34


//for文を使って配列に数字を入れて表示させる。
let sum = (nums) => {
	let total = 0;
	for(num of nums){
		total += num;
	}
	return total;
};

console.log(sum([1,35,6,8]));//expected 50

//レストパラメーターを使うと。。。

let sum = (...nums){
	let total = 0;
	for(num of nums){
		total += num;
	}
	return total;
}

console.log(sum(1,45,75,32));
</code>
</pre>


<h3>無名関数と名前付き関数の違い</h3>
<ul>
<li>
名前付き関数の場合デバックの時にわかりやすい。グーグルは名前付き関数を見ている。
</li>
<li>
変数に無名関数やアロー関数を代入した場合その変数名がネームプロパティーになる。推測される。
</li>
</ul>
<pre>
<code>
//変数に無名関数やアロー関数を代入した場合その変数名がネームプロパティーになる。
let sayHi = function hi() {};

sayHi = function () {
	return 'hi';
};

console.dir(sayHi); //expected　sayHi()
</code>
</pre>
<h3>引数は後から変更可能</h3>
<ul>
<li>引数はあとから変更可能。</li>
<li>パラメーターは常に固定ではない</li>
<li>ただこちらは読みにくくなるのでできるだけ避けてください。</li>
</ul>
<pre>
<code>

let subtract = (a,b, callback) => {
	//ここで変更してる。
	a = 30;
	let result = a-b;
	callback(result)
}


subtract(10, 3, function (result){
	console.log(result) //expected 27
}); 

</code>
</pre>
<h3>関数とオブジェクトの見分け方</h3>
<ul>
<li>type of 演算子で見分けられる。</li>
</ul>
<pre>
<code>

typeof{} //expected object

typeof[] function() {} //expected function

</code>
</pre>




	<pre>
		<code>
//ES2015における引数の記述方法
//引数のデフォルト値


function getTriangle(base=1, height=1){
return base*height/2;
}

console.log(getTriangle(5)); // expected 2.5
		</code>
	</pre>
	
<p>可変長引数の関数を定義する</p>
	<pre>
		<code>
function sum(...nums){
let result = 0;
for(let num of nums){if(typeof num !== 'number'){
throw new Error('指定地が数値ではありません　'+ num);
}
result += num;
}
return result; 
}


//名前付き引数でコードを読みやすくする。
function getTriangle({base=1, height=1}){
return base * height/2;
}

console.log({base:5, height:4});


//オブジェクトから特定のプロパティだけを取り出す。
/*この 例 で あれ ば、 show 関数 は 引数 として オブジェクト 全体 を 受け取り ます が、関数 側 では、 name プロパティ だけを 分割 代入 によって 取り出し て い ます。
複数 のプロパティ を 必要 と する 場合 にも、
関数 の 呼び出し 側 で、 個々 の プロパティ を 意識 せ ず、
オブジェクト を まるごと 渡せる のが 良い ところ です。 また、 必要 な プロパティ が
変化 し た 場合 にも、 呼び出し 側 の コード に 影響 が 及び ませ ん。*/

function show({name}){
console.log(name);
};

let member = {
mid: "Y0001",
name: "Satoshi Nakamoto",
address: "satoshinakamoto@sample.com"
}

show(member);
		</code>


	</pre>

	<p>関数の引数も関数ー高階関数</p>

	<p>「 JavaScript の 関数 は データ 型 の 一種」 です。 つまり、 関数 そのもの も また、 ほか の 数値 型 や 文字列 型 などと 同様、 関数 の 引数として 引き渡し たり、 戻り 値 として 返し たり する こと が できる という こと です。 そして、 その よう に「 関数 を 引数、 戻り 値 として 扱う 関数」 の こと を 高階 関数 と 呼び ます。</p>
	<pre>
		<code>
//高階関数arrayWalkを定義
function.arrayWalk(data,f){
for(var key in data){
f(data[key], key);
}
}
//配列を処理するためのユーザーを定義
function showElement(value, key) {
console.log(key + ':' + value);
}

var ary = {1,2,4,8,16};
arrayWalk(ary, showElement);

//expected
0: 1
1: 2
2: 4
3: 8
4: 16

		</code>
	</pre>

	<p>使い捨ての関数は匿名関数で</p>
	<p> 匿名 関数（ 関数 リテラル） を 利用 する こと で、 関数 呼び出し の コード に 関数 を 直接 指定 でき ます。 これ によって、 コード が 短く なっ た のは もちろん です が、 関連 する 処理 が1つ の 文 で 記述 できる こと から、 呼び出し 元 の コード と 実際 の 処理 を 規定 し て いる 関数 との 関係 が わかり やすく なり、コード が 読み やすく なっ た と 思い ませ ん か。また、 一度 限り しか 使用 し ない 関数 に 名前 ─ ─ しかも、 グローバル スコープ の 名前 ─ ─ を つけ ず に 済む ので、「 意図 せ ぬ 名前 の 重複 を 回避 できる」 という 意味 も あります。 この よう な 記法 は、 より 高度 な スクリプト を 記述 する うえ で 重宝 し ます し、多く の JavaScript プログラマー が 好ん で 利用 し て いる ので、 外部 ライブラリ などを読み解く 際 にも 有用 です。 ぜひとも、 ここ で しっかり と 押さえ て おき ましょ う。</p>
	<pre>
		<code>
fucntion arrayWalk(data, f){
for(var key in data){

}
}

var ary = {1,2,4,8,16};
arrayWalk{
ary,
function(value, key){
console.log(key + ':' + value);
}
}
		</code>
	</pre>

	<h3>Reduceメソッド</h3>
	<pre>
		<code>
///Reduce method

const array1 = [4,6,5,7];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
(accumulator, currentValue) => accumulator + currentValue,
initialValue
);


console.log(sumWithInitial);
// Expected output: 22


const string = "DISNEY WORLD";
const stringArray = string.split('');

function tag(accumulate, recentValue) {
return `${accumulate}&lt;${recentValue}>`;
	}

	function reduce(array, callback, defaultValue) {
	let accumulate = defaultValue;

	for (let i = 0; i < array.length; i++) {
	let recentValue = array[i];
	accumulate = callback(accumulate,recentValue);
	}
	return accumulate;
	}

	const result = reduce(stringArray, tag, "");
	console.log(result);//Expected Disney world


		</code>
	</pre>







</body>


</html>