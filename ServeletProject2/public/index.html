<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<!-- Highlight.js -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/vs.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<!-- main.js -->
	<script type="text/javascript" src="main.js" defer></script>
	<!-- css -->
	<link rel="stylesheet" href="styles.css">
	<!--fontawesome link for drop navigation bar  -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<title>Javascript Turtorial</title>
</head>

<body>
	<div class="topnav" id="myTopnav">
		<a href="index.html" class="active">Home</a>
		<a href="index.html" class="active">Javascript</a>
		<a href="mysql_turtorial.html">MySQL</a>
		<a href="dom.html">DOM</a>
		<a href="java.html">Java</a>
		<a href="jsp.html">JSP</a>
		<a href="servlet.html">Servlet</a>
		<a href="about.html">About</a>
		<a href="javascript:void(0);" class="icon" onclick="myFunction()">
			<i class="fa fa-bars"></i>
		</a>
	</div>
	<form id="language">
		<select name="select">
			<option value="index.html" selected>日本語</option>
			<option value="index-english.html">English</option>
		</select>
	</form>
	<h1>Javascript Turtorial</h1>
	<div class="header_image">
	<img src="\pleiades\2022-09\workspace\ServeletProject2\headerIMG.jpg" alt="img"  width="390px"height="320px">
	</div>
	<p>こちらはとにかく例を貼りまくったサイトになります。わからない例題は、グーグルのコンソールをつかって実装することをお勧めします。キーワードを指定してください。コマンドFまたはコントロールFを使うことをお勧めします。</p>
	<p>特にわからなかったところ</p>
	<ol>
		<li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Functions">関数</a></li>
		<li><a href="https://developer.mozilla.org/ja/docs/Glossary/Callback_function">コールバック関数</a></li>
		<li><a href="https://takayamato.com/eventlistener/">documentcontentloaded vs loaded</a></li>
		<li><a href="https://takayamato.com/eventlistener/">式と文</a></li>
		<li><a href="https://jsprimer.net/basic/operator/#ternary-operator">三項演算子</a></li>
	</ol>
		
<!--	<h3>Function ! document.getElementById textContent = ()</h3>
	<p id="output"></p>
	<p id="output1"></p>
	<p id="output2"></p>

	<h3>For Statement,document.getElementById insertAdjacentHTML </h3>
	<p> insertAdjacentHTML() は、第二引数で指定するテキストを HTML または XML としてパースし、
		その結果であるノードを DOM ツリー内の指定された位置（第一引数で指定）に挿入します。
		これは挿入先の要素を再度パースするものではないため、既存の要素や要素内部の破壊を伴いません。
		余分なシリアル化のステップを回避できる分、 innerHTML
		への代入による直接的な操作よりもはるかに高速な動作となります。
	</p>
	<p>To do List</p>
	<ul id="list">
	</ul>

	<h4 id="array">Array List Using Json</h3>
	<p>Javascriptの配列はいろいろな型を入れることができる。</p>

	<table>
		<tr>
			<td id="name"></td>
			<td id="age"></td>
			<td id="city"></td>
		</tr>
	</table>

	<p id="arrybox"></p>
	<p id="microsoftComputers_name"></p>
	<p id="microsoftComputers_colors"></p>
	<p id="microsoftComputers_price"></p>
-->

<h3>letを使い変数を作る。</h3>
<ul>
<li>=の右側値を「初期値」</li>
<li>二回同じ変数名で宣言することはできない。</li>
</ul>
<pre>
<code>
let apple = "Mac";
console.log(apple);
 //expected Mac

//代入できる。
apple="iphone";
console.log(apple);
//expected iphone


</code>
</pre>
<h3>constを使い定数を作る。</h3>
<ul>
<li>代入はできない。</li>
<li>定数をつかうことで後からの修正が可能になる。</li>
<li>コードが変数に代わるので読みやすくなる。</li>
<li>2つを除いて特殊な記号は変数名には入れることはできない。</li>
<li>「$」「_」ドルマークとアンダーバーは変数にいれることができる。</li>
<li>変数名に対して、数字は先頭に来てはいけない。</li>
<li>変数名は一般的に英語で書く。</li>
<li>単語単語で区切る時には、キャメルケース。単語の初めは大文字。-> appleBanana</li>
<li>あとはアンダースコアーで区切る。スネークケース　-> apple_Banana　一般的には使わない。</li>
</ul>
<pre>
<code>
const apple = "Mac";

console.log(apple) //expected Mac

//代入はできません。
apple = "ipad";
console.log(apple);
//expected エラーが起きます。
</code>
</pre>

<h3>Javascriptのルール　式と文</h3>
<p>Ecmascriptで明確な式と文の定義は別にない。式とはなにか？それは、変数の代入時に右辺に書くものである。例えば　let x = 5;　let y = 8; let z = x + y; この 「x + y」はしきである。この式をJavascriptが読むことを「評価する」と言います。では文とは何か？実行すると何かをすることを指します。厳密の定義は置いて、セミコロンで一文ととらえる。if文やfor文などが文と呼ばれる。文は式になることはできない。さらにここから大事なのが、文を書く場所に式はかける。だからIf文の中にconsole.log();とかも書ける。<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference">（ここで上げている例は一部に過ぎない。）</a> あと意外と重要なのがブロック分です。｛｝ブロック文ないで定義された変数は外側からアクセスすることはできないといことは覚えよう。</p>



	<pre>
		<code>
const animals = ["Lion", "Giraff", "Gorilla", "Dog", "Snake", "Rabbit"];

//フォー文をつかったときと同じ結果がでる。簡略も可能である。
animals.forEach(function(v, i, animals) {
console.log(v)
})
//アロー関数で書き直すと。。。
animals.forEach((v, i, animals)　=> {
console.log(v)
});
//第二第三引数が必要ない場合は、かっこ省略と波かっこも省略できる。
//できるだけ変数をへらすことができる。＝バグが少なくなる。軽くなる。
animals.forEach(v　=>console.log(v));


for(let i = 0; i &lt; animals.length; i++) { const v=animals[i]; console.log(v); }

let array = ['apple', 'banana', 'grape'];
array = [1,2,3];
array = [1, 'apple', true, array];
array = ['apple', 'banana', 'grape'];
console.log(array[0]) //expected apple

array.push("pinapple");
console.log('array');

 </code>
	</pre>
	<h3>配列とforeachメソッド</h3>


	<pre>
		<code>
const animals = ["Lion", "Giraff", "Gorilla", "Dog", "Snake", "Rabbit"];

//フォー文をつかったときと同じ結果がでる。簡略も可能である。
animals.forEach(function(v, i, animals) {
console.log(v)
})
//アロー関数で書き直すと。。。
animals.forEach((v, i, animals)　=> {
console.log(v)
});
//第二第三引数が必要ない場合は、かっこ省略と波かっこも省略できる。
//できるだけ変数をへらすことができる。＝バグが少なくなる。軽くなる。
animals.forEach(v　=>console.log(v));


for(let i = 0; i &lt; animals.length; i++) { const v=animals[i]; console.log(v); }

let array = ['apple', 'banana', 'grape'];
array = [1,2,3];
array = [1, 'apple', true, array];
array = ['apple', 'banana', 'grape'];
console.log(array[0]) //expected apple

array.push("pinapple");
console.log('array');

 </code>
	</pre>
	<h3>オブジェクト キーとバリューが並んでいる塊。</h3>
	<p>キーとバリューをセットでプロパティと呼ぶこともある。</p>

	<pre>
		<code>
	//object
const coffee =  {
	//name property
	name : 'chocolate Mocha", 
	size : 350,
	isHot: true,
	toppings : ['Cinnamon', 'Caramel'],
	nutritions : {
		calories : 430,
		sugar : 53,
		caffeine: 100,
	},
};

console.log(coffee,size) // expected 350
coffee.isHot = false;
coffee.barista = 'Tom'

const coffee = {
    name: "Matcha Latte",
    size: "tall",
    price: "450",
    tempature: "hot",
    addSweet: true,
};

coffee.addSweet
//expected true
coffee.name
//expected 'Matcha Latte'
coffee.price
//expected '450'
 </code>
	</pre>

<!--	<h3>フォームの入力内容を取得する。</h3>
	<section>
		<form action="#" id="form">
			<input type="text" name="word">
			<input type="submit" value="search">
		</form>
		<p id="output3">
		</p>
	</section>



	<section>
		<p>次のワールドカップまで</p>
		<p class="timer"> <span id="day"></span>日<span id="hour"></span>時間<span id="min"></span>分<span id="sec"></span>秒
		</p>
	</section>
 -->
 
 <h3>null vs undefined</h3>
	<p>nullは意図的に何も値を入れていないときに使う。Undefiinedは意図せず値が入っていなかったときなどにUndefiinedと返す。</p>
	
	<h3>動的型付け言語</h3>
	<p>動的型付け言語の場合には、途中で変数のデータ型が変わることも許容されます。つまり、数値型の変数に文字列を代入することもできるのです。宣言時にNumber（数値）であった変数ですが、文字列を代入してもエラーにはなりません。文字列が代入されたタイミングでデータ型がString（文字列）に変換されるためです。このように、JavaScriptではデータ型が自動的に付与されるため、データ型を強く意識する必要がありません。他の言語では、例えば数値型の変数に文字列を入れるとエラーになってしまいますが、JavaScriptではそれが起こりません。</p>
<h3> Typeof演算子</h3>
	<pre>
		<code>
typeof "Hello"
'string'
typeof 3
'number'
typeof true
'boolean'
typeof [1,2,3]
'object'
typeof null
'object'
typeof undefined
'undefined'
typeof {name:"Tom"}
'object'

		</code>
	</pre>
<h3>While文</h3>
	<pre>
		<code>
 
 let count = 0;
 
 while (count &lt; 10){
	console.log(count);
	count += 1;
}

//expected 0,1,2,3,4....

		</code>
	</pre>
<h3>do While文</h3>
	<pre>
		<code>
 上記の例と下記の例を見比べてみて
 
 
 let count = 100;
 while(count > 10) {
	console.log('while Counting...:' count);
	count += 1;
}
 
 let count = 0;
 
 do {
	console.log("do while Counting..."count);
	count += 1;
	
}while(count &lt; 10);

//expected 0,1,2,3,4....

		</code>
	</pre>
	<h3> FOR文</h3>
	<pre>
		<code>
		
for(;;) ⇐の意味は三つ式を取りますよという意味。

const secondexample = [122,444,556,634];
//iは添え字という意味合いがある。ofの時は使わない。
//ofでは添え字が渡ってくる。
for (let i of secondexample){
console.log(i);
}


//inでは値がわたってくる。
const arry = [1,3,5,6,7,9]
for (let i in arry) {
console.log(i); //output 1,3,5,6,7,9
}


ちなみにletはこうも書ける。
let a = 1, b = 2;
よってfor文ではこう書ける。

for (
	let pumbpkinCount = 0, i = 0;
	pumbpkinCount &lt; 10;
	pumbpkinCount +=1, i += 1
) {
	console.log(pumbpkinCount);
}

for (let i=0; i&lt; todos.length; i++){ console.log(todos[i]);　 <br>
	//output //*completed: true id: 1 title: "go to a movie theate

	completed: true
	id:2 ..続く
	*/
	console.log(todos[i].title);　
	//go to a movie theater
	//go shopping
	//having dinner

	}


const fruits = ["apple", "grape", "banana"];


//拡張For文：一般的にはconstを使う。letも使える。配列の時のみに使う。
for (const fruit of fruits) {
	console.log(fruit)
}
//inは一般的にobjectに使う。


const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

for (const customer in coffee) {
	console.log(customer)
}


		</code>
	</pre>

	<h3>break文</h3>
	<pre>
		<code>

const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

for (const customer in coffee) {
	console.log(customer);
	console.log(coffee[customer]);
	
	if(customer === 'size'){
		console.log('break!');
		break;　//ここで動きが止まる。
	}
}
		</code>
	</pre>
	<h3>continue文</h3>
	<pre>
		<code>

const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

for (const customer in coffee) {
	if(customer === 'size'){
		console.log('continue...');
		continue;　//ここからスキップが始まる。
	}
	console.log(customer);
	console.log(coffee[customer]);
	
}
		</code>
	</pre>
	<h3>ラベル文 あんまり使われない。</h3>
	<pre>
		<code>
ラベル文はbreak文とcontinue文と一緒に使う。
hello:{}


const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

coffeeLabel:if (true){
 for (const customer in coffee) {
	if(customer === 'size'){
		console.log('continue...');
		break coffeeLabel;
	}
	console.log(customer);
	console.log(coffee[customer]);
	
}
	console.log("Do you wanna have another a cup of coffee?")
	
} // expected name caffe latte continue... 
//↑の場合"Do you wanna have another a cup of coffee?"は出力されず、If文の外側に移動することになる。ラベル文が内側と外側で同じ名前と定義されている場合はエラーになる。ただし、外側と外側で同じ名前をもつラベル文の場合はエラーにはならない。なぜなら、全く違う変数とみなされるから。またノートすると、ラベル文は関数に対しては使えない。
		</code>
	</pre>
<h3>if文　演算子</h3>
	<pre>
		<code>
//二つの値が一致するかどうか？」の時にIf文を使う。
//等値演算子
//＝＝　の時は左辺と右辺の方は気にしないでデータが等しいかどうかを決める
//同値演算子
//＝＝＝の時は左辺と右辺のデータの方も含めて等しいかどうかを決める。
同じであればtrueを返す

const number = 10;

if (number){
console.log(" Yes"); 
} else if(true) { 
	console.log("No"); 
	} else { 
		console.log("error"); 
		}

 
 let ok = false;
 let maybeok = false;
  //↓真偽地	
if(ok) {
	console.log('ok');
} else if (maybeok) {
	console.log('maybe okay');
	} else { //falseの場合のみ
	console.log('no!');
}


ok = 1 === 1;
ok = "hello" === "hello";
ok = 1 !== 2;
ok = 1 == 2; 

ok = 1 > 0; //expected true　大なり
ok = 1 &lt; 0; //exxpected false 小なり
ok = "a" &lt; "b"; // expected true
ok = "A" &lt; "a"; //expected true
console.log(ok);


falsy false として扱われる値
false
0
-0
On
null
undefined
NaN

************
論理演算子
ok = false && true;
ok = false || false;
//Truethy Falseyの場合はどうなるのか？
ok = 'hello' && 'hi'; //アンド演算子は、右側がtruethyであれば、右側を返す。
ok = '' || 'hi'; //or演算子は左側がtruethyであれば、左側を返す。


const x = 15;
ok = x === 10 || (x > 12 && userName);

if(ok) {
	console.log("ok");
} else {
	console.log('No');
}
console.log(ok); 

ok = !true //「!」は反対の意味を表す。expected false 
ok = !'hello' // expected false 
ok = !x; // expected false 
ok = !!x; //expected true これは！！ふたつだから。
console.log(ok); 
		 </code>
	</pre>
	
	<h3>try catch　finally文</h3>
	<pre>
		<code>
try {
	console.log('do');
} catch {
	console.log('catch an error');
}
console.log('done');

//expected do done

try {
	//変数チョコレートを適当に入れる。
	console.log(chocolate);
} catch {
	console.log('catch an error');
}
console.log('done');　
//expected catch an error done


//もう少し複雑にしてみるとキャッチの中にさらにトライを入れることができる。
try {
	console.log(chocolate);
} catch {
	console.log('catch an error');
	
	try {
		console.log(chocolate)
	} catch {
		console.log('error occured')
	}
} 
console.log('done');　
//expected catch an error error occured done


//finallyは必ず出力される

try {
	console.log(chocolate);
} catch {
	console.log('catch an error');
	//どんな理由であれファイナリーは実行される。優先順位はめちゃくちゃ高い。
}  finally {  
	console.log('done...')
} 
//expected catch an error done...
		</code>
	</pre>
	<h3>三項演算子</h3>
	<a href="https://jsprimer.net/basic/operator/#ternary-operator">詳しくはこちらを。</a>
<pre>
	<code>

const ok  = "hello"
ok = ok ? 'OK' : 'NO';

console.log(ok);

	</code>
</pre>
	<h3>switch文</h3>
<pre>
	<code>
例えばこのようなコードがあったとする。
if(vegetable === "tomato") {
	console.log('tomato is red');
} else if (vegetable === "pumpkin"){
	console.log("pumpkin miso soup.")
} else if (vegetable === "onion"){
	console.log("onion is good with steak.")
}

switch文で書いてみると・・・。
switch (vegetable) {
	case 'tomato':
		console.log('tomato is red');
		break;
	case 'pumpkin'
		console.log("pumpkin miso soup.");
		break;
	case 'onion'
		console.log("onion is good with steak.");
		break;
	default: 
		console.log('not found');
}

switchとブロック分を使ってみると・・。
switch (vegetable) {	{
	case 'tomato':
		const message = 'tomato is red'	
		console.log(message);
		break;
}
	{
		case 'pumpkin'
		const message = "pumpkin miso soup."
		console.log(message);
		break;
	}
	
	{
		case 'onion'
		const message = "onion is good with steak."
		console.log(message);
		break;
	}
	{
		default: 
		console.log('not found');
	}
}

	</code>
</pre>
	<h3>Global Scope Local Scope </h3>
	<p>スコープ とは、「 変数 が スクリプト の 中 の どの 場所 から 参照 できる か」 を 決める 概念 です。 JavaScript の スコープ は、 以下 の 2 つ に 分類 でき ます。 ・スクリプト
		全体 から
		参照 できる グローバル スコープ ・定義 さ れ た 関数 の 中 で のみ 参照 できる ローカル スコープ</p>
<pre>
	<code>
const newValue = 'Hello';	変数をつくって関数の中で呼んでみる。
		
function add(num1, num2){
	console.log(newValue); //これは呼び出せる。
	const value = num1 + num2;　//関数のなかに変数を作る。
	return value;
}
console.log(value)//これは呼び出せない。
const returnedValue = add(2,3); 

************
関数の外側からは変数にアクセスはできない
************
スコープがすべての場所、ここでいう、const newValue = 'Hello'はグローバルスコープ
またはグローバル変数と呼ぶ。

const returnedValue = add(2,3); 
</code>
</pre>
	<img src="\pleiades\2022-09\workspace\ServeletProject2\javascript_turtorial_img1.jpg" alt="img" width="390px"
		width="340px">
	</p>ローカル変数は関数の先頭で宣言することを心がける。なぜならば、<a>href="https://developer.mozilla.org/ja/docs/Glossary/Hoisting">変数</a>の巻き上げをふせぐため。</p>
<pre>
<code>
関数の中だけしか扱えないようなconst value = num1 + num2;
変数をローカルスコープまたはローカル関数と呼ぶ。または関数スコープとも呼ぶ。　
************
関数の内側と外側に同じキーの変数があった場合、優先して呼ばれるのは内側の変数。
*****************
これをシャドウぃんぐと呼ぶ
const newValue = 'Hello';	//変数をつくって関数の中で呼んでみる。
		
function add(num1, num2){
	console.log(newValue); //これは呼び出せる。
	const newValue = num1 + num2;　//関数のなかに変数を作る。
	return value;
}
</code>
</pre>

。
	<pre>
		<code>
ファンクションコンストラクターの配下の変数はその宣言場所にかかわらず、
常にグローバルスコープとみなされる
var scope = 'Global Variable'; <br>
function checkScope() {<br>
var scope = 'Local Variable'; <br>
var f_ lit = function() { return scope; }; <br>
console. log( f_ lit()); 結果： Local Variable<br>
var f_ con = new Function(' return scope;'); <br>
console. log( f_ con()); // 結果： Global Variable }

		</code>
	</pre>

	<h3>関数Function アロー関数</h3>
	<p>関数は巻き上げられる。関数は一番初めに読み込まれるため、戻り値の下にあろうが、呼び出される。</p>
	<pre>
		<code>

//普通のFunction
//function hello(name) {
//console.log('hello' + name);
//}

//hello("Tom");

//普通のFunction
function getTriangle (base, height) {
return base * height/2;
}

console.log("Triangle area :" getTriangle(5,2));


function add(){
    console.log(2+2);
    }
  add(); //呼び出し方
//expected 4
    
//パラメーターと引数。
  
              //↓パラメーター
 function add(num1, num2){
	
	console.log() num1 + num2);
}
  //↓引数（argument）
add(5,3);

//expected 8

//return文
//return文のあとの文法はすべて無視される。

function add(num1, num2){
	return num1 + num2;
}

const returnedValue = add(2,3);
console.log(returnedValue);


		</code>
	</pre>
	
	
	<pre>
		<code>
//関数は静的な構造を宣言する。
console.log("Triangle area:" + getTriangle(5,2));

function getTriangle(base, height){
return base * height/2;
}
上記の例はエラーとはならない。ファンクション命令はコードを
解析・コンパイルするタイミングで関数を登録している。

console.log("Triangle area:" + getTriangle(5,2));

var getTriangle = function(base, height){
return base * height /2;
}

上記の例はエラー。ファンクション命令tとは異なり、
関数リテラル・ファンクションコンストラクターは実行時（代入時）に評価される。
この場合だと、呼び出し元のコードよりも前に記述しなければならない。
//アロー関数 二行以上の場合は波かっこが必要。一行の時は波かっこ消去可能。

const hello = (name, age) => {
console.log('hello' + name + age)
console.log('hello' + name + age)
}
hello("Erran", 27);
		</code>
	</pre>

	<pre>
		<code>
//アロー関数 functionもreturnも略せる。
var getTriangle = (base, height) => base * height /2;
console.log("Traiangle area:' getTriangle(5,2);// expected 5

//アロー関数はFor文でよく使われる。

const numbers = [1,2,3,4,5,6,7,8];

numbers.forEach(function(value) {
console.log(value);
}) //output 1,2,3,4,5,6,7,8

numbers.forEach(value => console.log(value))//output 1,2,3,4,5,6,7,8
		</code>


	</pre>

	<pre>
		<code>
//Callback function (コールバック関数)
コールバック関数とは、引数として他の関数に渡され、
外側の関数の中で呼び出されて、何らかのルーチンやアクションを完了させる関数のことです。
function doSomething(a, b, callback) {
const result = callback(a,b);
console.log(result);
}

function multiple(a,b) {
return a * b;
}

doSomething(8, 9, multiple);
		</code>


	</pre>

	<pre>
		<code>
//コールバック関数例２
const lists = ["number1", "number2", "number3"];

function forEach(lists, callback) {
for(let i = 0; i &lt; lists.length; i++){ callback(lists[i])
	}
	}
function showLists(list) { console.log(list);}
function addList(list) { list="This is " + list showLists(list); }
 forEach(lists, addList);
 // This is number1 .... continue... 
//関数を定義せずにforEachを使ってそのまま書くこともできる。 forEach(lists, function(list) 
list="This is " + list; showLists(list); }); 
//output // This is number1 .... continue...
		</code>


	</pre>


	<pre>
		<code>
//ES2015における引数の記述方法
//引数のデフォルト値


function getTriangle(base=1, height=1){
return base*height/2;
}

console.log(getTriangle(5)); // expected 2.5

		</code>


	</pre>
	<pre>
		<code>
//可変長引数の関数を定義する

function sum(...nums){
let result = 0;
for(let num of nums){if(typeof num !== 'number'){
throw new Error('指定地が数値ではありません　'+ num);
}
result += num;
}
return result;
}


//名前付き引数でコードを読みやすくする。
function getTriangle({base=1, height=1}){
return base * height/2;
}

console.log({base:5, height:4});


//オブジェクトから特定のプロパティだけを取り出す。
この 例 で あれ ば、 show 関数 は 引数 として オブジェクト 全体 を 受け取り ます が、
関数 側 では、 name プロパティ だけを 分割 代入 によって 取り出し て い ます。
複数 のプロパティ を 必要 と する 場合 にも、
関数 の 呼び出し 側 で、 個々 の プロパティ を 意識 せ ず、
オブジェクト を まるごと 渡せる のが 良い ところ です。 また、 必要 な プロパティ が
変化 し た 場合 にも、 呼び出し 側 の コード に 影響 が 及び ませ ん。

function show({name}){
console.log(name);
};

let member = {
mid: "Y0001",
name: "Satoshi Nakamoto",
address: "satoshinakamoto@sample.com"
}

show(member);

		</code>


	</pre>

	<p>関数の引数も関数ー高階関数</>

	<p>「 JavaScript の 関数 は データ 型 の 一種」 です。 つまり、 関数 そのもの も また、 ほか の 数値 型 や 文字列 型 などと 同様、 関数 の 引数として 引き渡し たり、 戻り 値 として 返し たり する こと が できる という こと です。 そして、 その よう に「 関数 を 引数、 戻り 値 として 扱う 関数」 の こと を 高階 関数 と 呼び ます。</p>
	<pre>
		<code>
//高階関数arrayWalkを定義
function.arrayWalk(data,f){
for(var key in data){
f(data[key], key);
}
}
//配列を処理するためのユーザーを定義
function showElement(value, key) {
console.log(key + ':' + value);
}

var ary = {1,2,4,8,16};
arrayWalk(ary, showElement);

//expected
0: 1
1: 2
2: 4
3: 8
4: 16

		</code>
	</pre>

	<p>使い捨ての関数は匿名関数で</p>
	<p> 匿名 関数（ 関数 リテラル） を 利用 する こと で、 関数 呼び出し の コード に 関数 を 直接 指定 でき ます。 これ によって、 コード が 短く なっ た のは もちろん です が、 関連 する 処理 が1つ の 文 で 記述 できる こと から、 呼び出し 元 の コード と 実際 の 処理 を 規定 し て いる 関数 との 関係 が わかり やすく なり、コード が 読み やすく なっ た と 思い ませ ん か。また、 一度 限り しか 使用 し ない 関数 に 名前 ─ ─ しかも、 グローバル スコープ の 名前 ─ ─ を つけ ず に 済む ので、「 意図 せ ぬ 名前 の 重複 を 回避 できる」 という 意味 も あります。 この よう な 記法 は、 より 高度 な スクリプト を 記述 する うえ で 重宝 し ます し、多く の JavaScript プログラマー が 好ん で 利用 し て いる ので、 外部 ライブラリ などを読み解く 際 にも 有用 です。 ぜひとも、 ここ で しっかり と 押さえ て おき ましょ う。</p>
	<pre>
		<code>
fucntion arrayWalk(data, f){
for(var key in data){

}
}

var ary = {1,2,4,8,16};
arrayWalk{
ary,
function(value, key){
console.log(key + ':' + value);
}
}
		</code>
	</pre>

	<h3>Reduceメソッド</h3>
	<pre>
		<code>
///Reduce method

const array1 = [4,6,5,7];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
(accumulator, currentValue) => accumulator + currentValue,
initialValue
);


console.log(sumWithInitial);
// Expected output: 22


const string = "DISNEY WORLD";
const stringArray = string.split('');

function tag(accumulate, recentValue) {
return `${accumulate}&lt;${recentValue}>`;
	}

	function reduce(array, callback, defaultValue) {
	let accumulate = defaultValue;

	for (let i = 0; i array.length; i++) {
	let recentValue = array[i];
	accumulate = callback(accumulate,recentValue);
	}
	return accumulate;
	}

	const result = reduce(stringArray, tag, "");
	console.log(result);//Expected Disney world


		</code>
	</pre>

	<h3>DOM</h3>
	<p>document.querySelectorAll()</p>
	<p>「querySelector()」は、JavaScriptから任意のHTML要素を検出・取得することができるメソッドになります。
		JavaScriptには以前から「getElementById()」とか「getElemetnsByClassName()」などHTML要素を取得できるメソッドはありました。
		しかし、「querySelector()」を使うとid属性値・class属性値などを意識せずにjQuery感覚でHTML要素をセレクタ指定することができます。
		つまり、簡単に言うと「querySelector()」だけであらゆるHTML要素を取得することができるわけです。</p>

	<a href="https://takayamato.com/eventlistener/">domcontentloaded vs loaded </a>
	<p>細かいところ解説していくと長くなるので、とりあえずこの２段階を知っていれば大丈夫です。
		①DOMツリーを読み込む
		②画像、CSSなどの外部ファイルの読み込み完了
		①の時に全てのHTMLタグを樹形図のように表し、その構造（テキスト情報も含む）を書き出します。
		まずページ全体の骨格を作っていると思っておいてOKです。
		②ではその骨格の形成が完了した後に使われている画像やCSSを読み込んでページを完成させていきます。
		ネット環境がめちゃくちゃ悪いところで何かのページを見ると、まず文章構造（文字や改行）だけが反映されて、その後にCSSが適用されて画像が読み込まれますよね。
		これは重要なポイントです。</p>

	<p style="color: blue;">正規表現</p>
	<img src="\pleiades\2022-09\workspace\ServeletProject2\formalExpressions_img4.jpg" alt="img" width="390px"
		width="340px">
	<h3>いろいろなメソッド</h3>
	<p style="color:blue;">foreachメソッド</p>
	<p>foreachめっそどは配列内の要素を、指定した関数で順に処理するためのメソッドです。</p>

	<p>配列オブジェクトcallback：個々の要素を処理するための関数that：</p>
	<p>関数callbackの中でthis（5.1.5項)が示すオブジェクト</p>

	<pre>
		<code>array. forEach( callback [,that]) array：
var data = [2, 3, 4, 5]; data. forEach( function( value, index, array) {
console.log( value * value); // 結果：4、9、16、25 });
		</code>
	</pre>
	<ul>
		<li>第一引数う→要素の値</li>
		<li>第二引数→インデックス番号</li>
		<li>第三引数→元の配列</li>
	</ul>

	<p style="color:blue;">sortメソッド</p>
	<p>sort() メソッドは、配列の要素をその場でソートし、ソートされた同じ配列の参照を返します。既定のソート順は昇順で、要素を文字列に変換してから、 UTF-16 コード単位の値の並びとして比較します。ソートの時間的・空間的予測値は実装に依存するため、保証はできません。</p>
	<pre>
		<code>
const months = ['March', 'Jan', 'Feb', 'Dec'];
months.sort();<br>
console.log(months);<br>
// Expected output: Array ["Dec", "Feb", "Jan", "March"]<br>

const array1 = [1, 30, 4, 21, 100000];<br>
array1.sort();<br>
console.log(array1);<br>
// Expected output: Array [1, 100000, 21, 30, 4]
		</code>
	</pre>
	<br>
	<br>
	<br>
	<pre>
		<code>
var classes = ['部長', '課長', '主任', '担当'];<br>
var members = [
{ name: '鈴木 清 子', clazz: '主任' }, <br>
{ name: '山口 久 雄', clazz: '部長' },<br>
{ name: '井上 太郎', clazz: '担当' }, <br>
{ name: '和田 知 美', clazz: '課長' },<br>
{ name: '小 森 雄 太', clazz: '担当' }, ];
console. log( members. sort(<br>
function( x, y) { return classes. indexOf( x. clazz) - classes. indexOf( y. clazz); ← ❶ }))
		</code>
	</pre>
	<p style="color:blue;">someメソッド</p>
	<p>some() メソッドは、指定された関数で実装されているテストに、配列の中の少なくとも 1 つの要素が 合格するかどうかを判定します。配列の中で指定された関数が true を返す要素を見つけた場合は true
		を返し、そうでない場合は false を返します。それ以外の場合は false を返します。配列は変更しません。</p>
	<pre>
		<code>
const array = [1, 2, 3, 4, 5];<br>

// Checks whether an element is even<br>
const even = (element) => element % 2 === 0;<br>

console.log(array.some(even));<br>
// Expected output: true

		</code>
	</pre>
	

	<h3>Javascriptにおけるオブジェクト指向の特徴</h3>
	<p>ここ までに 見 て き た よう に、 JavaScript は れっきとした オブジェクト 指向 言語 です。 しかし、 Java や C ++、 C# といった オブジェクト 指向 言語 とは 根本的 に 異なる 点 が
		あり ます。 それ は「『 インスタンス 化／ インスタンス』 という 概念 は ある ものの、 いわゆる『 クラス』 が なく、『 プロトタイプ（ ひな型）』 という 概念 だけが 存在 する」 という 点 です。
		プロトタイプ とは、「 ある オブジェクト の 元 と なる オブジェクト」 の こと。 JavaScript では、（ クラス の 代わり に） プロトタイプ を 利用 し て、 新た な オブジェクト を 生成 し て
		いく こと になり ます。 この よう な 性質 から、 JavaScript の オブジェクト 指向 は、 プロトタイプ ベース の オブジェクト 指向 と 呼ば れる こと も あり ます。 クラス ベース の
		オブジェクト 指向 に どっぷり と 浸かっ て しまっ た 方 にとって は、 やや イメージ が つかみ にくい かも しれ ませ ん が、 プロトタイプ とは、 要は「 より 縛り の 弱い クラス の よう な
		もの」 と 思っ て おい て ください。</p>
	<p style="color: blue;">プロパティとメソッド</p>
	<p>ここ で 注目 す べき は、 this キーワード です。 this キーワード は、 コンス トラクター によって 生成 さ れる インスタンス（ つまり、 自分自身） を 表す もの です。 this キーワード
		に対して 変数 を 指定 する こと で、 インスタンス の プロパティ を 設定 でき ます。関数 リテラル） を 指定 できる 点 にも 注目 し て ください。 JavaScript において は、 厳密 には
		メソッド という 独立 し た 概念 は なく、 値 が 関数 オブジェクト で ある プロパティ が メソッド と 見なさ れる の です。 ここ では、 getName プロパティ に 関数 リテラル を 引き渡し て
		いる ので、 いわゆる「 getName メソッド」 を 宣言 し た こと に なる わけ です。 実際 に、 Member オブジェクト を インスタンス 化 し て、 getName メソッド を 呼び出し て みる
		と、 たしかに「 山田 祥 寛」 という 文字列 が 表示 さ れる こと が 確認 できる はず です。</p>
	<pre>
		<code>
var Member = function( firstName, lastName) {
this. firstName = firstName;
this. lastName = lastName;
this. getName = function() {
return this. lastName + ' ' + this. firstName; } };

var mem = new Member(' 祥 寛', '山田');
console. log( mem. getName()); // 結果： 山田 祥 寛
		</code>
	</pre>
	<p style="color: blue;">動的にメソッドを追加する。</p>
	<img src="\pleiades\2022-09\workspace\ServeletProject2\protoTypeclassBase.jpg" width="390px" width="340px">
	<p>Java の よう な クラス ベース の オブジェクト 指向 に 慣れ た 方 なら ば、「 同一 の クラス を 元 に 生成 さ れ た インスタンス は 同一 の メンバー を 持つ」 のが 常識 です が、
		プロトタイプ ベース の オブジェクト 指向（ JavaScript） の 世界 では、 同一 の クラス を 元 に 生成 さ れ た インスタンス で あっ ても、 それぞれ が 持つ メンバー は 同一 で ある とは
		限ら ない という こと です。 ここ では、 新た に メンバー を 追加 し て いる だけ です が、 delete 演算子（ 2. 4. 6 項） で インスタンス から 既存 の メンバー を 削除 する こと も
		でき ます。 この よう な ゆる さが、 本章 の 冒頭 で、 プロトタイプ が「 より 縛り の 弱い クラス の よう な もの」 と 述べ た 理由 です。 </p>
	<pre>
		<code>
var Member = function (firstName, lastName{
this.firstName = firstName;
this.lastName = lastName; };

var mem = new Member(' 祥 寛', '山田');
mem. getName = function() {
return this. lastName + ' ' + this. firstName;
}
console. log( mem. getName()); // 結果： 山田 祥 寛
		</code>
	</pre>





</body>


</html>