<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<!-- Highlight.js -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/vs.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<!-- main.js -->
	<script type="text/javascript" src="main.js" defer></script>
	<!-- css -->
	<link rel="stylesheet" href="styles.css">
	<!--fontawesome link for drop navigation bar  -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<title>Javascript Turtorial</title>
</head>

<body>
	<div class="topnav" id="myTopnav">
		<a href="index.html" class="active">Home</a>
		<a href="index.html" class="active">Javascript</a>
		<a href="mysql_turtorial.html">MySQL</a>
		<a href="dom.html">DOM</a>
		<a href="java.html">Java</a>
		<a href="jsp.html">JSP</a>
		<a href="servlet.html">Servlet</a>
		<a href="about.html">About</a>
		<a href="javascript:void(0);" class="icon" onclick="myFunction()">
			<i class="fa fa-bars"></i>
		</a>
	</div>
	<form id="language">
		<select name="select">
			<option value="index.html" selected>日本語</option>
			<option value="index-english.html">English</option>
		</select>
	</form>
	<h1>Javascript Turtorial</h1>
	<div class="header_image">
	<img src="\pleiades\2022-09\workspace\ServeletProject2\headerIMG.jpg" alt="img"  width="390px"height="320px">
	</div>
	<p>こちらはとにかく例を貼りまくったサイトになります。わからない例題は、グーグルのコンソールをつかって実装することをお勧めします。キーワードを指定してください。コマンドFまたはコントロールFを使うことをお勧めします。</p>
	<p>特にわからなかったところ</p>
	<ol>
		<li><a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Functions">関数</a></li>
		<li><a href="https://developer.mozilla.org/ja/docs/Glossary/Callback_function">コールバック関数</a></li>
		<li><a href="https://takayamato.com/eventlistener/">documentcontentloaded vs loaded</a></li>
		<li><a href="https://takayamato.com/eventlistener/">式と文</a></li>
		<li><a href="https://jsprimer.net/basic/operator/#ternary-operator">三項演算子</a></li>
	</ol>
		
<!--	<h3>Function ! document.getElementById textContent = ()</h3>
	<p id="output"></p>
	<p id="output1"></p>
	<p id="output2"></p>

	<h3>For Statement,document.getElementById insertAdjacentHTML </h3>
	<p> insertAdjacentHTML() は、第二引数で指定するテキストを HTML または XML としてパースし、
		その結果であるノードを DOM ツリー内の指定された位置（第一引数で指定）に挿入します。
		これは挿入先の要素を再度パースするものではないため、既存の要素や要素内部の破壊を伴いません。
		余分なシリアル化のステップを回避できる分、 innerHTML
		への代入による直接的な操作よりもはるかに高速な動作となります。
	</p>
	<p>To do List</p>
	<ul id="list">
	</ul>

	<h4 id="array">Array List Using Json</h3>
	<p>Javascriptの配列はいろいろな型を入れることができる。</p>

	<table>
		<tr>
			<td id="name"></td>
			<td id="age"></td>
			<td id="city"></td>
		</tr>
	</table>

	<p id="arrybox"></p>
	<p id="microsoftComputers_name"></p>
	<p id="microsoftComputers_colors"></p>
	<p id="microsoftComputers_price"></p>
-->

<h3>letを使い変数を作る。</h3>
<ul>
<li>=の右側値を「初期値」</li>
<li>二回同じ変数名で宣言することはできない。</li>
</ul>
<pre>
<code>
let apple = "Mac";
console.log(apple);
 //expected Mac

//代入できる。
apple="iphone";
console.log(apple);
//expected iphone


</code>
</pre>
<h3>constを使い定数を作る。</h3>
<ul>
<li>代入はできない。</li>
<li>定数をつかうことで後からの修正が可能になる。</li>
<li>コードが変数に代わるので読みやすくなる。</li>
<li>2つを除いて特殊な記号は変数名には入れることはできない。</li>
<li>「$」「_」ドルマークとアンダーバーは変数にいれることができる。</li>
<li>変数名に対して、数字は先頭に来てはいけない。</li>
<li>変数名は一般的に英語で書く。</li>
<li>単語単語で区切る時には、キャメルケース。単語の初めは大文字。-> appleBanana</li>
<li>あとはアンダースコアーで区切る。スネークケース　-> apple_Banana　一般的には使わない。</li>
</ul>
<pre>
<code>
const apple = "Mac";

console.log(apple) //expected Mac

//代入はできません。
apple = "ipad";
console.log(apple);
//expected エラーが起きます。
</code>
</pre>
<h3>Varとletの違い。</h3>
<ul>
<li>varは使われていません。</li>
<li>違い1つ目：同じ変数名を再宣言できる。</li>
<li>違い2つ目：スコープ（変数を参照できる範囲の事。）の違い。letは波かっこ内でしかスコープは共有されないが、varは波かっこがあろうともグローバル変数になる。ただしvarには例外があって<strong>関数の場合のみ関数の中からでしかアクセスはできない。</strong>　このことからvarはvarは関数スコープ　letはブロック関数と言われる。</li>
<li>違い3つ目：グローバルオブジェクトの一部になる。</li>
<li>違い4つ目：巻き上げ　hoisting</li>
</ul>
<pre>
<code>
var hello = 'hello';
hello = 'hi'
console.log(hello);


//違い一つ目：同じ変数名を再宣言できる。
var hello = 'hello';
var hello = 'hi';
console.log(hello); //これはエラーにならずにhiが表示される。

//これをletに変えた場合、エラーが起きる。
let hello = 'hello';
let hello = 'hi';
console.log(hello); //error 

//違い2つ目：スコープの違い。 
var hello = 'hello';
var hello = 'hi';
{
	
	let tomato = 'tomato'
}
console.log(tomato); //スコープの問題でこれはエラーが起きる。

//しかしこれをvarで置き換えると、エラーが起き「ない」。
var hello = 'hello';
var hello = 'hi';
{
	
	var tomato = 'tomato'
}
console.log(tomato);

//違い3つ目：グローバルオブジェクトの一部になる。
var apple = 'apple';
console.log(globalThis); //グローバルオブジェクトにアップルが新しく追加される。

//違い4つ目：巻き上げ　hoisting

console.log(apple); // 普通ここはletだったらエラーが起きる。
var apple = 'apple";
console.log(apple); 

</code>
</pre>

<h3>グローバルオブジェクト</h3>
<ul>
<li>グローバルオブジェクトを一覧で管理している。</li>
<li>最初にJavascriptエンジンでブラウザで呼んでいる。</li>
<li>globalThis　グローバルオブジェクトが見れる。</li>
<li>組み込み型（ビルトイン）のおかげでいちいち呼び出さなくても使える。</li>
<li></li>
</ul>
<pre>
<code>
//コンソールドットログはどこからきたの？
console.log("hello")

//グローバルオブジェクトを見れる。
conosle.log(globalThis);
</code>
</pre>
<h3>Javascriptのルール　式と文</h3>
<p>Ecmascriptで明確な式と文の定義は別にない。式とはなにか？それは、変数の代入時に右辺に書くものである。例えば　let x = 5;　let y = 8; let z = x + y; この 「x + y」はしきである。この式をJavascriptが読むことを「評価する」と言います。では文とは何か？実行すると何かをすることを指します。厳密の定義は置いて、セミコロンで一文ととらえる。if文やfor文などが文と呼ばれる。文は式になることはできない。さらにここから大事なのが、文を書く場所に式はかける。だからIf文の中にconsole.log();とかも書ける。<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference">（ここで上げている例は一部に過ぎない。）</a> あと意外と重要なのがブロック分です。｛｝ブロック文ないで定義された変数は外側からアクセスすることはできないといことは覚えよう。</p>

<h3>useStrictモードとは</h3>
<p>現代のJavascriptが適用される。useStrictを宣言するとルールが制限される。一方で使わないと昔のJavascriptの書き方が適用されるのでルールが緩くなる。サッカーで言うと、VR判定がなくなる。</p>
<h3>primitiveとobjectとは</h3>
<p>Objectはオブジェクト、配列、関数を表す。Primitiveはnumber, string, boolean, undefined, nullなどを表す。</p>
<ul>
<li>Primitiveの場合　：　let x= 8;はメモリに保存される。メモリは電源を切ったら忘れる。</li>
<li>Objectの場合　：　let x = {x:0}はとある特定の住所に保存される。xという番地に数字が間接的に保存される。x=yになった場合もともとの住所はは動かさないでxの番地だけを移動する。オブジェクトはいちいち運ばない。アドレスがｘとｙに入っていると思ってください。</li>
<li>Constは再代入を防いでいる。</li>
<li>Constでも値が変わることをmutable　可変と言います。</li>
<li>オブジェクトはmutableである。</li>
<li>逆に変わらないことをimmutable　　primitiveは不変である　と言います。</li>
</ul>

<pre>
<code>
//参照が違うことを示す。番地と住所の話。
const coffee = {
	name: 'Caffe Latte',
}

const coffee3 = {
	name : 'Caffe Latte',
}

console.log(coffee === coffee3); //expected false 


//Constは再代入を防いでいる「だけ」。

const coffee  = {
	name:'Caffe Latte',
}

//example 1 

const coffee = {
	name: 'Caffe Latte',
};

const coffee2 = coffee;
coffee2.name = 'Charamel Machiato';
console.log(coffee); //Charamel Machiato Constなのに値が変わってるよね？

</code>
</pre>

<h3>レキシカル環境(LexicalEnviroment)</h3>
<p>レキシカル環境とはキーとバリューをセットにしたDBみたいな感じ。オブジェクトである。</p>
<ul>
<li>レキシカル環境ではブロックがみつかった場合また更にもう一つのレキシカル環境をつくる。</li>
<li>同じLexical環境内で変数があって呼んだ場合には同じLexical環境内の変数変数が呼び出される。</li>
<li>関数の場合呼び出されたときにLexical環境が作り出される。</li>
<li>関数の場合別々のLexical環境が作り出されるので上書きはされない。</li>
<li>クロージャ：レキシカル環境はアドレスのように指定される。</li>
<li>理論上レキシカル環境は一生残る。</li>
</ul>

<pre>
<code>
let x = 1; // (1)
let a = function( ) {
    console.log( x );
};
let b = function( ) {
    let x  = 2;
    a ( );    // 1

    let b2 = function( ) {
        let x = 3;
        a ( );    // 1
    };
    b2( );
};
b( );


let message = "さんこんにちは";

function a( name ){

    let m = name + message;    

    return function ( ){
         console.log( m );
    };
}

let a2 = a( "Taro" );
let a3 = a( "Hanako" ); // 2回呼び出したので変数mが上書きされるはず

a2( );   // Taroさんこんにちは ← 上書きされていない！！
a3( );   // Hanakoさんこんにちは
</code>
</pre>


<h3>クロージャを使ってプライベートを作る方法</h3>
<p></p>
<ul>
<li>メソッドをつかって書き換えれなくする。</li>
</ul>
<pre>
<code>

let generatePerson = () => {
	let age = 0;
	return {
		name: () => 'Taro',
		getAge: () => age,
		incrementAge: () => {
			age +=1;
		},
	};
};

const taro = generatePerson('Taro');
console.log(taro.getAge()); //expected 0 
taro.incrementAge();
taro.incrementAge();
console.log(taro.getAge()); //expected 2

const tom = generatePerson('Tom');
tom.incrementAge();
tom.incrementAge();
tom.incrementAge();
console.log(tom.getAge()); // expected 3 ここがレキシカル環境が完全に別れている証拠。

</code>
</pre>

<h3>実行コンテキストスタック excution context stack</h3>
<p></p>
<ul>
<li></li>
</ul>
<pre>
<code>

const c = () => {
	return 'hello';
}

const b = () => {
	return c();
}

const a = () => {
	return b();
}

a();


</code>
</pre>
<h3>Object.assignを使ってオブジェクトを拡張する方法</h3>
<p>Object.assignでオブジェクトを結合する。</p>
<ul>
<li>「()」の中の右側が常に優先される。</li>
<li> 無限にとれる。 </li>
<li> スプレッド構文をObject.assignにいれたいときには{}を使う。 </li>
</ul>
<pre>
<code>
const ob1 = {
	a : 1,
}

const ob2 = {
	b: 2,
}

const ob3 = {
	c: 3,
}
Object.assign(ob1,ob2, ob3); //「()」の中の右側が常に優先される。無限にとれる。
console.log(ob1); //expected {a:1, b:2, c:3} 

const coffee = {
	isHot : false,
	charamel : true,
	machiato : true,
	milk : true,
	espresso : true,
}

const newCoffee = Object.assign({}, coffee, {isHot : true}); //スプレッド構文をObject.assignにいれたいときには{}を使う。
console.log(newCoffee === coffee );


</code>
</pre>
<h3>分割代入はこうなっている。</h3>
<p></p>
<ul>
<li>例題①をよく見てほしい。titletitleを取得してbook.titleにいれて、呼ぶとSpiderManと呼ばれる。</li>
<li>オブジェクトをつけると別名をつけられる。</li>
<li> でふぉると値も設定できる。あんま使われない。</li>
<li> 残り全てという書き方もできる。...etc</li>
<li> var let も同じように動く。そして関数も動く。</li>
<li> 関数のパラメーターの中にオブジェクトをまんま入れることができる。</li>
<li> 関数を呼び出すときにそのオブジェクトの変数を読んであげる。</li>
</ul>
<pre>
<code>
//example 1



const book = {
	title : 'SpiderMan',
	price : 9.99,
	
}
const title = book.title;　//titleを取得してbook.titleにいれると

console.log(title); //expected SpiderMan


const {title, price} = book; //分割代入はこうする！！！
console.log(title, price ); //expected SpiderMan 9.99 


//example 2
const book = {
	title : 'SpiderMan',
	price : 9.99,	
}


const {title: booktitle, price} = book; //ここでオブジェクトに別名をつけてる。
console.log(booktitle, price);　//expected SpiderMan 9.99 


//example 3

const book = {
	title : 'SpiderMan',
	price : 9.99,	
	author : { 
		firstName : 'Imanishi',
		lastName :  'Tsuyoshi',
	},
}


const {title: booktitle, price, author : {firstName, lastName}} = book; //ここでオブジェクトに別名をつけてる。
console.log(booktitle, price, firstName, lastName);　//expected SpiderMan 9.99 Imanishi Tsuyoshi

//example4

const book = {
	title : 'SpiderMan',
	price : 9.99,	
	author : { 
		firstName : 'Imanishi',
		lastName :  'Tsuyoshi',
	},
	isbn : 2345874,
	description : 'A man fights for the revenge.',
}


const aboutBook = ({
title: booktitle, 
price,
author : {firstName, lastName},
publisher:pub = 'Sanakaku Shikaku', //デフォルト値が設定できる　bookの方にはpublisherは含まれていません。
...etc　//スプレッド構文を追加できる。isbnとdescriptionはaboutBookには含まれていないことに注目。

})=> {
	console.log(booktitle, price, firstName, lastName, pub, etc);　
};

aboutBook(book); 
</code>
</pre>

<h3> in演算子を利用してプロパティの有無を調べる。</h3>
<p>特定のプロパティがあればTrueなければFalseを返す。</p>
<ul>
<li>「book.title !== undefined」と 「'title' in book」 は違う。</li>
<li>「book.title !== undefined」の場合呼び出しても表示されない。タイトルはないってことになる。</li>
<li>「'title' in book」の場合、タイトルはあるってことになる。でもundefinedは呼び出されない。</li>

</ul>
<pre>
<code>
//example 1
const book ={
	title : 'the begginer couse of Javascript',
}

book.title = undefined //ここでundefinedにすると
　
if(book.title !== undefined){ //ここは表示されない。
	console.log(book.title); // the begginer couse of Javascript
	console.log('title' in book); //expected true
}

//example 2 
const book ={
	title :'the begginer couse of Javascript',
}

book.title = undefined;

if('title' in book ) {
	console.log(book.title);//expected the begginer couse of Javascript
	console.log('title' in book); //expected true 
}
</code>
</pre>


<h3>配列とforeachメソッド</h3>
	<pre>
		<code>
const animals = ["Lion", "Giraff", "Gorilla", "Dog", "Snake", "Rabbit"];

//フォー文をつかったときと同じ結果がでる。簡略も可能である。
animals.forEach(function(v, i, animals) {
console.log(v)
})
//アロー関数で書き直すと。。。
animals.forEach((v, i, animals)　=> {
console.log(v)
});
//第二第三引数が必要ない場合は、かっこ省略と波かっこも省略できる。
//できるだけ変数をへらすことができる。＝バグが少なくなる。軽くなる。
animals.forEach(v　=>console.log(v));


for(let i = 0; i &lt; animals.length; i++) { const v=animals[i]; console.log(v); }

let array = ['apple', 'banana', 'grape'];
array = [1,2,3];
array = [1, 'apple', true, array];
array = ['apple', 'banana', 'grape'];
console.log(array[0]) //expected apple

array.push("pinapple");
console.log('array');

 </code>
	</pre>
	<h3>オブジェクト キーとバリューが並んでいる塊。</h3>
	<p>キーとバリューをセットでプロパティと呼ぶこともある。</p>

	<pre>
		<code>
	//object
const coffee =  {
	//name property
	name : 'chocolate Mocha", 
	size : 350,
	isHot: true,
	toppings : ['Cinnamon', 'Caramel'],
	nutritions : {
		calories : 430,
		sugar : 53,
		caffeine: 100,
	},
};

console.log(coffee,size) // expected 350
coffee.isHot = false;
coffee.barista = 'Tom'

const coffee = {
    name: "Matcha Latte",
    size: "tall",
    price: "450",
    tempature: "hot",
    addSweet: true,
};

coffee.addSweet
//expected true
coffee.name
//expected 'Matcha Latte'
coffee.price
//expected '450'
 </code>
	</pre>

<!--	<h3>フォームの入力内容を取得する。</h3>
	<section>
		<form action="#" id="form">
			<input type="text" name="word">
			<input type="submit" value="search">
		</form>
		<p id="output3">
		</p>
	</section>



	<section>
		<p>次のワールドカップまで</p>
		<p class="timer"> <span id="day"></span>日<span id="hour"></span>時間<span id="min"></span>分<span id="sec"></span>秒
		</p>
	</section>
 -->
 
 <h3>null vs undefined</h3>
	<p>nullは意図的に何も値を入れていないときに使う。Undefiinedは意図せず値が入っていなかったときなどにUndefiinedと返す。</p>
	
	<h3>動的型付け言語</h3>
	<p>動的型付け言語の場合には、途中で変数のデータ型が変わることも許容されます。つまり、数値型の変数に文字列を代入することもできるのです。宣言時にNumber（数値）であった変数ですが、文字列を代入してもエラーにはなりません。文字列が代入されたタイミングでデータ型がString（文字列）に変換されるためです。このように、JavaScriptではデータ型が自動的に付与されるため、データ型を強く意識する必要がありません。他の言語では、例えば数値型の変数に文字列を入れるとエラーになってしまいますが、JavaScriptではそれが起こりません。</p>
<h3> Typeof演算子</h3>
	<pre>
		<code>
typeof "Hello"
'string'
typeof 3
'number'
typeof true
'boolean'
typeof [1,2,3]
'object'
typeof null
'object'
typeof undefined
'undefined'
typeof {name:"Tom"}
'object'

		</code>
	</pre>
<h3>While文</h3>
	<pre>
		<code>
 
 let count = 0;
 
 while (count &lt; 10){
	console.log(count);
	count += 1;
}

//expected 0,1,2,3,4....

		</code>
	</pre>
<h3>do While文</h3>
	<pre>
		<code>
 上記の例と下記の例を見比べてみて
 
 
 let count = 100;
 while(count > 10) {
	console.log('while Counting...:' count);
	count += 1;
}
 
 let count = 0;
 
 do {
	console.log("do while Counting..."count);
	count += 1;
	
}while(count &lt; 10);

//expected 0,1,2,3,4....

		</code>
	</pre>
	<h3> FOR文</h3>
	<pre>
		<code>
		
for(;;) ⇐の意味は三つ式を取りますよという意味。

const secondexample = [122,444,556,634];
//iは添え字という意味合いがある。ofの時は使わない。
//ofでは添え字が渡ってくる。
for (let i of secondexample){
console.log(i);
}


//inでは値がわたってくる。
const arry = [1,3,5,6,7,9]
for (let i in arry) {
console.log(i); //output 1,3,5,6,7,9
}


ちなみにletはこうも書ける。
let a = 1, b = 2;
よってfor文ではこう書ける。

for (
	let pumbpkinCount = 0, i = 0;
	pumbpkinCount &lt; 10;
	pumbpkinCount +=1, i += 1
) {
	console.log(pumbpkinCount);
}

for (let i=0; i&lt; todos.length; i++){ console.log(todos[i]);　 <br>
	//output //*completed: true id: 1 title: "go to a movie theate

	completed: true
	id:2 ..続く
	*/
	console.log(todos[i].title);　
	//go to a movie theater
	//go shopping
	//having dinner

	}


const fruits = ["apple", "grape", "banana"];


//拡張For文：一般的にはconstを使う。letも使える。配列の時のみに使う。
for (const fruit of fruits) {
	console.log(fruit)
}
//inは一般的にobjectに使う。


const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

for (const customer in coffee) {
	console.log(customer)
}


		</code>
	</pre>

	<h3>break文</h3>
	<pre>
		<code>

const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

for (const customer in coffee) {
	console.log(customer);
	console.log(coffee[customer]);
	
	if(customer === 'size'){
		console.log('break!');
		break;　//ここで動きが止まる。
	}
}
		</code>
	</pre>
	<h3>continue文</h3>
	<pre>
		<code>

const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

for (const customer in coffee) {
	if(customer === 'size'){
		console.log('continue...');
		continue;　//ここからスキップが始まる。
	}
	console.log(customer);
	console.log(coffee[customer]);
	
}
		</code>
	</pre>
	<h3>ラベル文 あんまり使われない。</h3>
	<pre>
		<code>
ラベル文はbreak文とcontinue文と一緒に使う。
hello:{}


const coffee = {
	name: "caffe latte",
	size: "tall",
	isHot: true,
};

coffeeLabel:if (true){
 for (const customer in coffee) {
	if(customer === 'size'){
		console.log('continue...');
		break coffeeLabel;
	}
	console.log(customer);
	console.log(coffee[customer]);
	
}
	console.log("Do you wanna have another a cup of coffee?")
	
} // expected name caffe latte continue... 
//↑の場合"Do you wanna have another a cup of coffee?"は出力されず、If文の外側に移動することになる。ラベル文が内側と外側で同じ名前と定義されている場合はエラーになる。ただし、外側と外側で同じ名前をもつラベル文の場合はエラーにはならない。なぜなら、全く違う変数とみなされるから。またノートすると、ラベル文は関数に対しては使えない。
		</code>
	</pre>
<h3>if文　演算子</h3>
	<pre>
		<code>
//二つの値が一致するかどうか？」の時にIf文を使う。
//等値演算子
//＝＝　の時は左辺と右辺の方は気にしないでデータが等しいかどうかを決める
//同値演算子
//＝＝＝の時は左辺と右辺のデータの方も含めて等しいかどうかを決める。
同じであればtrueを返す

const number = 10;

if (number){
console.log(" Yes"); 
} else if(true) { 
	console.log("No"); 
	} else { 
		console.log("error"); 
		}

 
 let ok = false;
 let maybeok = false;
  //↓真偽地	
if(ok) {
	console.log('ok');
} else if (maybeok) {
	console.log('maybe okay');
	} else { //falseの場合のみ
	console.log('no!');
}


ok = 1 === 1;
ok = "hello" === "hello";
ok = 1 !== 2;
ok = 1 == 2; 

ok = 1 > 0; //expected true　大なり
ok = 1 &lt; 0; //exxpected false 小なり
ok = "a" &lt; "b"; // expected true
ok = "A" &lt; "a"; //expected true
console.log(ok);


falsy false として扱われる値
false
0
-0
On
null
undefined
NaN

************
論理演算子
ok = false && true;
ok = false || false;
//Truethy Falseyの場合はどうなるのか？
ok = 'hello' && 'hi'; //アンド演算子は、右側がtruethyであれば、右側を返す。
ok = '' || 'hi'; //or演算子は左側がtruethyであれば、左側を返す。


const x = 15;
ok = x === 10 || (x > 12 && userName);

if(ok) {
	console.log("ok");
} else {
	console.log('No');
}
console.log(ok); 

ok = !true //「!」は反対の意味を表す。expected false 
ok = !'hello' // expected false 
ok = !x; // expected false 
ok = !!x; //expected true これは！！ふたつだから。
console.log(ok); 
		 </code>
	</pre>
	
	<h3>try catch　finally文</h3>
	<pre>
		<code>
try {
	console.log('do');
} catch {
	console.log('catch an error');
}
console.log('done');

//expected do done

try {
	//変数チョコレートを適当に入れる。
	console.log(chocolate);
} catch {
	console.log('catch an error');
}
console.log('done');　
//expected catch an error done


//もう少し複雑にしてみるとキャッチの中にさらにトライを入れることができる。
try {
	console.log(chocolate);
} catch {
	console.log('catch an error');
	
	try {
		console.log(chocolate)
	} catch {
		console.log('error occured')
	}
} 
console.log('done');　
//expected catch an error error occured done


//finallyは必ず出力される

try {
	console.log(chocolate);
} catch {
	console.log('catch an error');
	//どんな理由であれファイナリーは実行される。優先順位はめちゃくちゃ高い。
}  finally {  
	console.log('done...')
} 
//expected catch an error done...
		</code>
	</pre>
	<h3>三項演算子</h3>
	<a href="https://jsprimer.net/basic/operator/#ternary-operator">詳しくはこちらを。</a>
<pre>
	<code>

const ok  = "hello"
ok = ok ? 'OK' : 'NO';

console.log(ok);

	</code>
</pre>
	<h3>switch文</h3>
<pre>
	<code>
例えばこのようなコードがあったとする。
if(vegetable === "tomato") {
	console.log('tomato is red');
} else if (vegetable === "pumpkin"){
	console.log("pumpkin miso soup.")
} else if (vegetable === "onion"){
	console.log("onion is good with steak.")
}

switch文で書いてみると・・・。
switch (vegetable) {
	case 'tomato':
		console.log('tomato is red');
		break;
	case 'pumpkin'
		console.log("pumpkin miso soup.");
		break;
	case 'onion'
		console.log("onion is good with steak.");
		break;
	default: 
		console.log('not found');
}

switchとブロック分を使ってみると・・。
switch (vegetable) {	{
	case 'tomato':
		const message = 'tomato is red'	
		console.log(message);
		break;
}
	{
		case 'pumpkin'
		const message = "pumpkin miso soup."
		console.log(message);
		break;
	}
	
	{
		case 'onion'
		const message = "onion is good with steak."
		console.log(message);
		break;
	}
	{
		default: 
		console.log('not found');
	}
}

	</code>
</pre>
	<h3>Global Scope Local Scope </h3>
	<p>スコープ とは、「 変数 が スクリプト の 中 の どの 場所 から 参照 できる か」 を 決める 概念 です。 JavaScript の スコープ は、 以下 の 2 つ に 分類 でき ます。 ・スクリプト
		全体 から
		参照 できる グローバル スコープ ・定義 さ れ た 関数 の 中 で のみ 参照 できる ローカル スコープ</p>
<pre>
	<code>
const newValue = 'Hello';	変数をつくって関数の中で呼んでみる。
		
function add(num1, num2){
	console.log(newValue); //これは呼び出せる。
	const value = num1 + num2;　//関数のなかに変数を作る。
	return value;
}
console.log(value)//これは呼び出せない。
const returnedValue = add(2,3); 

************
関数の外側からは変数にアクセスはできない
************
スコープがすべての場所、ここでいう、const newValue = 'Hello'はグローバルスコープ
またはグローバル変数と呼ぶ。

const returnedValue = add(2,3); 
</code>
</pre>
	<img src="\pleiades\2022-09\workspace\ServeletProject2\javascript_turtorial_img1.jpg" alt="img" width="390px"
		width="340px">
	<p>ローカル変数は関数の先頭で宣言することを心がける。なぜならば、<a>href="https://developer.mozilla.org/ja/docs/Glossary/Hoisting">変数</a>の巻き上げをふせぐため。</p>
<pre>
<code>
関数の中だけしか扱えないようなconst value = num1 + num2;
変数をローカルスコープまたはローカル関数と呼ぶ。または関数スコープとも呼ぶ。　
************
関数の内側と外側に同じキーの変数があった場合、優先して呼ばれるのは内側の変数。
*****************
これをシャドウぃんぐと呼ぶ
const newValue = 'Hello';	//変数をつくって関数の中で呼んでみる。
		
function add(num1, num2){
	console.log(newValue); //これは呼び出せる。
	const newValue = num1 + num2;　//関数のなかに変数を作る。
	return value;
}
</code>
</pre>

。
	<pre>
		<code>
ファンクションコンストラクターの配下の変数はその宣言場所にかかわらず、
常にグローバルスコープとみなされる
var scope = 'Global Variable'; <br>
function checkScope() {<br>
var scope = 'Local Variable'; <br>
var f_ lit = function() { return scope; }; <br>
console. log( f_ lit()); 結果： Local Variable<br>
var f_ con = new Function(' return scope;'); <br>
console. log( f_ con()); // 結果： Global Variable }

		</code>
	</pre>

	<h3>関数Function アロー関数</h3>
	<ul>
	<li>関数はオブジェクトに過ぎない。</li>
	</ul>
	<pre>
	<code>
function add(a,b){
	return a + b;
}

console.log(add);
console.log(add.name);
console.log(add.length);
関数がオブジェクトなら代入できるよね？
const newAdd = add;
console.log(newAdd(3,4)); //expected 7 
	</code>
	</pre>

<p>関数式</p>
<p>関数は静的な構造を宣言する。</p>
<ul>
<li>関数を定義するときには2つの方法がある。</li>
<li>関数の宣言文をつかって関数を生み出す。</li>
<li>関数式を使って関数を生み出す。</li>
</ul>
	<pre>
	<code>
//名前付き関数式
let sayHi  = function hi(){
	return 'Hi';
}

console.log(sayHi()); //expected Hi

//名前がついていない関数をAnonymusFunction無名関数という。
sayHi = function (){};
console.log(sayHi());

console.log("Triangle area:" + getTriangle(5,2));

function getTriangle(base, height){
return base * height/2;
}
//上記の例はエラーとはならない。ファンクション命令はコードを
//解析・コンパイルするタイミングで関数を登録している。

console.log("Triangle area:" + getTriangle(5,2));

var getTriangle = function(base, height){
return base * height /2;
}

//上記の例はエラー。ファンクション命令tとは異なり、
//関数リテラル・ファンクションコンストラクターは実行時（代入時）に評価される。
//この場合だと、呼び出し元のコードよりも前に記述しなければならない。
//アロー関数 二行以上の場合は波かっこが必要。一行の時は波かっこ消去可能。

const hello = (name, age) => {
console.log('hello' + name + age)
console.log('hello' + name + age)
}
hello("Erran", 27);
	</code>
	</pre>
<p>関数宣言文VS関数式どっちで宣言したらいいのか？</p>
<ul>
<li>関数は巻き上げられる。関数は一番初めに読み込まれるため、戻り値の下にあろうが、呼び出される。</li>
<li>関数式は巻き上げられない。つまり関数宣言した前では呼び出せない。</li>
<li>一方関数宣言文は何処でも呼ぶことができるのと視覚的に関数とわかりやすい。</li>
<li>プロジェクトで統一することが大事。関数式を使うといいかも・。</li>
</ul>
	<pre>
		<code>
//普通のFunction
//function hello(name) {
//console.log('hello' + name);
//}

//hello("Tom");

//普通のFunction
function getTriangle (base, height) {
return base * height/2;
}

console.log("Triangle area :" getTriangle(5,2));


function add(){
    console.log(2+2);
    }
  add(); //呼び出し方
//expected 4
    
//パラメーターと引数。
  
//パラメーター
 function add(num1, num2){
	
	console.log() num1 + num2);
}
//引数（argument）
add(5,3);

//expected 8

//return文
//return文のあとの文法はすべて無視される。

function add(num1, num2){
	return num1 + num2;
}

const returnedValue = add(2,3);
console.log(returnedValue);
		</code>
	</pre>

<p>関数とメソッドの違い。</p>
<ul>
<li>キーとバリューセットをプロパティと呼ぶ。</li>
<li>つまりsayHiはプロパティである。</li>
<li>またはsayHiメソッドと言う。</li>
</ul>
<pre>
<code>

const person = {
	name : 'Taro',
//メソッド
	sayHi: function () {
		return 'hi';
	}
}
</code>
</pre>

<p>アロー関数 functionもreturnも略せる。３つの特徴</p>.
<ul>
<li> 無名関数の置き換えになる。無名関数の別の書き方がアロー関数。</li>
<li> だから関数に名前はいらない。</li>
<li>1. 一つに式をリターンする場合波かっこと且つリターンを省略できる。</li>
<li>2. パラメータが一つの場合、パラメータの〇括弧を省略できる。ただパラメータが一つの場合のみです。</li>
<li>3. thisというものです。後に説明</li>
<li> thisというものです。後に説明</li>
<li> アロー関数にオブジェクトはつけられない。式と認識するから。もしオブジェクトを入れたい場合は（）をつけてやる。</li>
</ul>
	<pre>
		<code>
//無名関数式
sayHi = function (name) {
	return `hi ${name}!`;
}
//アロー関数
sayHi = (name) => {
	return `Hi ${name}`;
}

//波かっこを消して且つリターンも省略
sayHi = (name) => `Hi ${name}`;

// アロー関数にオブジェクトはつけられない。
sayHi = (name) => {
	name: name;
}
じゃあどうするか？()をつけてやると式と認識する。
sayHi = (name) => ({
	name: name;
})

//アロー関数
var getTriangle = (base, height) => base * height /2;
console.log("Traiangle area:' getTriangle(5,2);// expected 5

//アロー関数はFor文でよく使われる。

const numbers = [1,2,3,4,5,6,7,8];

numbers.forEach(function(value) {
console.log(value);
}) //output 1,2,3,4,5,6,7,8

numbers.forEach(value => console.log(value))//output 1,2,3,4,5,6,7,8
		</code>
	</pre>

<p>Callback function (コールバック関数)</p>
<ul>
<li>
コールバック関数とは、引数として他の関数に渡され、
外側の関数の中で呼び出されて、何らかのルーチンやアクションを完了させる関数のことです。
</li>
<li>引数に関数は渡せる。頻繁度高く使われるので覚えよう。</li>
</ul>
	<pre>
		<code>
function doSomething(a, b, callback) {
const result = callback(a,b);
console.log(result);
}

function multiple(a,b) {
return a * b;
}

doSomething(8, 9, multiple);

//引数に関数は渡せる。

let subtract = (a, b, callback) => {
	let result = a - b;
	callback(result);
}

subtract(10,3, (result) => {
	console.log(result); //expected 7
});

subtract(19,4,(result) => {
	alert(result); //expected 15
});
		</code>


	</pre>
<p>コールバック関数例２</p>
	<pre>
		<code>
const lists = ["number1", "number2", "number3"];

function forEach(lists, callback) {
for(let i = 0; i &lt; lists.length; i++){ callback(lists[i])
	}
	}
function showLists(list) { console.log(list);}
function addList(list) { list="This is " + list showLists(list); }
 forEach(lists, addList);
 // This is number1 .... continue... 
//関数を定義せずにforEachを使ってそのまま書くこともできる。 forEach(lists, function(list) 
list="This is " + list; showLists(list); }); 
//output // This is number1 .... continue...
		</code>
	</pre>
<h3>デフォルトパラメータはこう使う</h3>	
<ul>
<li>
もし戻り値を返さなかったらどうなるの？
</li>
<li>デフォルト値を設定できる。</li>
<li>戻り値にUndefinedもいれることができる。</li>
<li>UndefinedだけがDefaut値に変換される。</li>
<li>引数が複数あった場合デフォルト値はデフォルトパラメータの最後に設定する。</li>
<li>こちらは例を見てください。デフォルト値が二つ以上あった場合はB=Aともできる。messageにnameを代入することができる。</li>
<li>引数を入れすぎた場合は無視される。</li>
</ul>
<pre>
<code>

sayHi = (name) => `Hi ${name}!`; 

console.log(sayHi('Aoi'));//expected Hi Aoi!

//もし戻り値を渡さなかったら？
sayHi = (name) => `Hi ${name}!`; 

console.log(sayHi());　//undefined 


//何も戻り値がなかった場合にデフォルト値を設定できる。
sayHi = (name = 'User') => `Hi ${name}!`; 

console.log(sayHi());　//expected Hi User!

//戻り値にUndefinedも入れることができる。
sayHi = (name = 'User') => `Hi ${name}!`; 

console.log(sayHi(undefined));　//expected Hi User!

//引数が複数あった場合デフォルト値はデフォルトパラメータの最後に設定する。
sayHi = (name, message=' how are you?') => `Hi ${name} ${message}`; 

console.log(sayHi('Rin'));　// Hi Rin how are you?

//デフォルト値が二つ以上あった場合はB=Aともできる。messageにnameを代入
sayHi = (name, message='${name}') => `Hi ${name} `; 

console.log(sayHi('Rin'));　// Hi Rin 

sayHi = (name, message='${name}') => `Hi ${message}`; 

console.log(sayHi('Rin', 'how are you?'));　// Hi how are you?
</code>
</pre>


<h3>レストパラメーターで無限個の引数を扱う方法</h3>
<ul>
<li>
「...」レストパラメーターを使うと数を無限個引き受けられる。
</li>
<li>
「...」レストパラメーターを使うときは必ずパラメータの最後に書く。
</li>
<li>
「...」レストパラメーターを使うときは必ず括弧をつける。
</li>
<li>
「...」レストパラメーター以外にもargumentsがあるがそれは使用しないようにしましょう。
</li>
</ul>
<pre>
<code>
普通に足していく
let sum = (a,b,c) => {
	return a + b + c;
}

console.log(sum(23,5,6)); //expected 34


//for文を使って配列に数字を入れて表示させる。
let sum = (nums) => {
	let total = 0;
	for(num of nums){
		total += num;
	}
	return total;
};

console.log(sum([1,35,6,8]));//expected 50

//レストパラメーターを使うと。。。

let sum = (...nums){
	let total = 0;
	for(num of nums){
		total += num;
	}
	return total;
}

console.log(sum(1,45,75,32));
</code>
</pre>


<h3>無名関数と名前付き関数の違い</h3>
<ul>
<li>
　名前付き関数の場合デバックの時にわかりやすい。グーグルは名前付き関数を見ている。
</li>
<li>
変数に無名関数やアロー関数を代入した場合その変数名がネームプロパティーになる。推測される。
</li>
</ul>
<pre>
<code>
//変数に無名関数やアロー関数を代入した場合その変数名がネームプロパティーになる。
let sayHi = function hi() {};

sayHi = function () {
	return 'hi';
};

console.dir(sayHi); //expected name: "sayHi"
</code>
</pre>
<h3>引数は後から変更可能</h3>
<ul>
<li>引数はあとから変更可能。</li>
<li>パラメーターは常に固定ではない</li>
<li>ただこちらは読みにくくなるのでできるだけ避けてください。</li>
</ul>
<pre>
<code>

let subtract = (a,b, callback) => {
	//ここで変更してる。
	a = 30;
	let result = a-b;
	callback(result)
}


subtract(10, 3, function (result){
	console.log(result) //expected 27
}); 

</code>
</pre>
<h3>関数とオブジェクトの見分け方</h3>
<ul>
<li>type of 演算子で見分けられる。</li>
</ul>
<pre>
<code>

typeof{} //expected object

typeof[] function() {} //expected function

</code>
</pre>




	<pre>
		<code>
//ES2015における引数の記述方法
//引数のデフォルト値


function getTriangle(base=1, height=1){
return base*height/2;
}

console.log(getTriangle(5)); // expected 2.5

		</code>


	</pre>
	
<p>可変長引数の関数を定義する</p>
	<pre>
		<code>
//

function sum(...nums){
let result = 0;
for(let num of nums){if(typeof num !== 'number'){
throw new Error('指定地が数値ではありません　'+ num);
}
result += num;
}
return result; 
}


//名前付き引数でコードを読みやすくする。
function getTriangle({base=1, height=1}){
return base * height/2;
}

console.log({base:5, height:4});


//オブジェクトから特定のプロパティだけを取り出す。
この 例 で あれ ば、 show 関数 は 引数 として オブジェクト 全体 を 受け取り ます が、
関数 側 では、 name プロパティ だけを 分割 代入 によって 取り出し て い ます。
複数 のプロパティ を 必要 と する 場合 にも、
関数 の 呼び出し 側 で、 個々 の プロパティ を 意識 せ ず、
オブジェクト を まるごと 渡せる のが 良い ところ です。 また、 必要 な プロパティ が
変化 し た 場合 にも、 呼び出し 側 の コード に 影響 が 及び ませ ん。

function show({name}){
console.log(name);
};

let member = {
mid: "Y0001",
name: "Satoshi Nakamoto",
address: "satoshinakamoto@sample.com"
}

show(member);

		</code>


	</pre>

	<p>関数の引数も関数ー高階関数</p>

	<p>「 JavaScript の 関数 は データ 型 の 一種」 です。 つまり、 関数 そのもの も また、 ほか の 数値 型 や 文字列 型 などと 同様、 関数 の 引数として 引き渡し たり、 戻り 値 として 返し たり する こと が できる という こと です。 そして、 その よう に「 関数 を 引数、 戻り 値 として 扱う 関数」 の こと を 高階 関数 と 呼び ます。</p>
	<pre>
		<code>
//高階関数arrayWalkを定義
function.arrayWalk(data,f){
for(var key in data){
f(data[key], key);
}
}
//配列を処理するためのユーザーを定義
function showElement(value, key) {
console.log(key + ':' + value);
}

var ary = {1,2,4,8,16};
arrayWalk(ary, showElement);

//expected
0: 1
1: 2
2: 4
3: 8
4: 16

		</code>
	</pre>

	<p>使い捨ての関数は匿名関数で</p>
	<p> 匿名 関数（ 関数 リテラル） を 利用 する こと で、 関数 呼び出し の コード に 関数 を 直接 指定 でき ます。 これ によって、 コード が 短く なっ た のは もちろん です が、 関連 する 処理 が1つ の 文 で 記述 できる こと から、 呼び出し 元 の コード と 実際 の 処理 を 規定 し て いる 関数 との 関係 が わかり やすく なり、コード が 読み やすく なっ た と 思い ませ ん か。また、 一度 限り しか 使用 し ない 関数 に 名前 ─ ─ しかも、 グローバル スコープ の 名前 ─ ─ を つけ ず に 済む ので、「 意図 せ ぬ 名前 の 重複 を 回避 できる」 という 意味 も あります。 この よう な 記法 は、 より 高度 な スクリプト を 記述 する うえ で 重宝 し ます し、多く の JavaScript プログラマー が 好ん で 利用 し て いる ので、 外部 ライブラリ などを読み解く 際 にも 有用 です。 ぜひとも、 ここ で しっかり と 押さえ て おき ましょ う。</p>
	<pre>
		<code>
fucntion arrayWalk(data, f){
for(var key in data){

}
}

var ary = {1,2,4,8,16};
arrayWalk{
ary,
function(value, key){
console.log(key + ':' + value);
}
}
		</code>
	</pre>

	<h3>Reduceメソッド</h3>
	<pre>
		<code>
///Reduce method

const array1 = [4,6,5,7];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
(accumulator, currentValue) => accumulator + currentValue,
initialValue
);


console.log(sumWithInitial);
// Expected output: 22


const string = "DISNEY WORLD";
const stringArray = string.split('');

function tag(accumulate, recentValue) {
return `${accumulate}&lt;${recentValue}>`;
	}

	function reduce(array, callback, defaultValue) {
	let accumulate = defaultValue;

	for (let i = 0; i array.length; i++) {
	let recentValue = array[i];
	accumulate = callback(accumulate,recentValue);
	}
	return accumulate;
	}

	const result = reduce(stringArray, tag, "");
	console.log(result);//Expected Disney world


		</code>
	</pre>

	<h3>DOM</h3>
	<p>document.querySelectorAll()</p>
	<p>「querySelector()」は、JavaScriptから任意のHTML要素を検出・取得することができるメソッドになります。
		JavaScriptには以前から「getElementById()」とか「getElemetnsByClassName()」などHTML要素を取得できるメソッドはありました。
		しかし、「querySelector()」を使うとid属性値・class属性値などを意識せずにjQuery感覚でHTML要素をセレクタ指定することができます。
		つまり、簡単に言うと「querySelector()」だけであらゆるHTML要素を取得することができるわけです。</p>

	<a href="https://takayamato.com/eventlistener/">domcontentloaded vs loaded </a>
	<p>細かいところ解説していくと長くなるので、とりあえずこの２段階を知っていれば大丈夫です。
		①DOMツリーを読み込む
		②画像、CSSなどの外部ファイルの読み込み完了
		①の時に全てのHTMLタグを樹形図のように表し、その構造（テキスト情報も含む）を書き出します。
		まずページ全体の骨格を作っていると思っておいてOKです。
		②ではその骨格の形成が完了した後に使われている画像やCSSを読み込んでページを完成させていきます。
		ネット環境がめちゃくちゃ悪いところで何かのページを見ると、まず文章構造（文字や改行）だけが反映されて、その後にCSSが適用されて画像が読み込まれますよね。
		これは重要なポイントです。</p>

	<p style="color: blue;">正規表現</p>
	<img src="\pleiades\2022-09\workspace\ServeletProject2\formalExpressions_img4.jpg" alt="img" width="390px"
		width="340px">
	<h3>いろいろなメソッド</h3>
	<p style="color:blue;">foreachメソッド</p>
	<p>foreachめっそどは配列内の要素を、指定した関数で順に処理するためのメソッドです。</p>

	<p>配列オブジェクトcallback：個々の要素を処理するための関数that：</p>
	<p>関数callbackの中でthis（5.1.5項)が示すオブジェクト</p>

	<pre>
		<code>array. forEach( callback [,that]) array：
var data = [2, 3, 4, 5]; data. forEach( function( value, index, array) {
console.log( value * value); // 結果：4、9、16、25 });
		</code>
	</pre>
	<ul>
		<li>第一引数う→要素の値</li>
		<li>第二引数→インデックス番号</li>
		<li>第三引数→元の配列</li>
	</ul>

	<p style="color:blue;">sortメソッド</p>
	<p>sort() メソッドは、配列の要素をその場でソートし、ソートされた同じ配列の参照を返します。既定のソート順は昇順で、要素を文字列に変換してから、 UTF-16 コード単位の値の並びとして比較します。ソートの時間的・空間的予測値は実装に依存するため、保証はできません。</p>
	<pre>
		<code>
const months = ['March', 'Jan', 'Feb', 'Dec'];
months.sort();<br>
console.log(months);<br>
// Expected output: Array ["Dec", "Feb", "Jan", "March"]<br>

const array1 = [1, 30, 4, 21, 100000];<br>
array1.sort();<br>
console.log(array1);<br>
// Expected output: Array [1, 100000, 21, 30, 4]
		</code>
	</pre>
	<br>
	<br>
	<br>
	<pre>
		<code>
var classes = ['部長', '課長', '主任', '担当'];<br>
var members = [
{ name: '鈴木 清 子', clazz: '主任' }, <br>
{ name: '山口 久 雄', clazz: '部長' },<br>
{ name: '井上 太郎', clazz: '担当' }, <br>
{ name: '和田 知 美', clazz: '課長' },<br>
{ name: '小 森 雄 太', clazz: '担当' }, ];
console. log( members. sort(<br>
function( x, y) { return classes. indexOf( x. clazz) - classes. indexOf( y. clazz); ← ❶ }))
		</code>
	</pre>
	<p style="color:blue;">someメソッド</p>
	<p>some() メソッドは、指定された関数で実装されているテストに、配列の中の少なくとも 1 つの要素が 合格するかどうかを判定します。配列の中で指定された関数が true を返す要素を見つけた場合は true
		を返し、そうでない場合は false を返します。それ以外の場合は false を返します。配列は変更しません。</p>
	<pre>
		<code>
const array = [1, 2, 3, 4, 5];<br>

// Checks whether an element is even<br>
const even = (element) => element % 2 === 0;<br>

console.log(array.some(even));<br>
// Expected output: true

		</code>
	</pre>
	

	<h3>Javascriptにおけるオブジェクト指向の特徴</h3>
	<p>ここ までに 見 て き た よう に、 JavaScript は れっきとした オブジェクト 指向 言語 です。 しかし、 Java や C ++、 C# といった オブジェクト 指向 言語 とは 根本的 に 異なる 点 が
		あり ます。 それ は「『 インスタンス 化／ インスタンス』 という 概念 は ある ものの、 いわゆる『 クラス』 が なく、『 プロトタイプ（ ひな型）』 という 概念 だけが 存在 する」 という 点 です。
		プロトタイプ とは、「 ある オブジェクト の 元 と なる オブジェクト」 の こと。 JavaScript では、（ クラス の 代わり に） プロトタイプ を 利用 し て、 新た な オブジェクト を 生成 し て
		いく こと になり ます。 この よう な 性質 から、 JavaScript の オブジェクト 指向 は、 プロトタイプ ベース の オブジェクト 指向 と 呼ば れる こと も あり ます。 クラス ベース の
		オブジェクト 指向 に どっぷり と 浸かっ て しまっ た 方 にとって は、 やや イメージ が つかみ にくい かも しれ ませ ん が、 プロトタイプ とは、 要は「 より 縛り の 弱い クラス の よう な
		もの」 と 思っ て おい て ください。</p>
	<p style="color: blue;">プロパティとメソッド</p>
	<p>ここ で 注目 す べき は、 this キーワード です。 this キーワード は、 コンス トラクター によって 生成 さ れる インスタンス（ つまり、 自分自身） を 表す もの です。 this キーワード
		に対して 変数 を 指定 する こと で、 インスタンス の プロパティ を 設定 でき ます。関数 リテラル） を 指定 できる 点 にも 注目 し て ください。 JavaScript において は、 厳密 には
		メソッド という 独立 し た 概念 は なく、 値 が 関数 オブジェクト で ある プロパティ が メソッド と 見なさ れる の です。 ここ では、 getName プロパティ に 関数 リテラル を 引き渡し て
		いる ので、 いわゆる「 getName メソッド」 を 宣言 し た こと に なる わけ です。 実際 に、 Member オブジェクト を インスタンス 化 し て、 getName メソッド を 呼び出し て みる
		と、 たしかに「 山田 祥 寛」 という 文字列 が 表示 さ れる こと が 確認 できる はず です。</p>
	<pre>
		<code>
var Member = function( firstName, lastName) {
this. firstName = firstName;
this. lastName = lastName;
this. getName = function() {
return this. lastName + ' ' + this. firstName; } };

var mem = new Member(' 祥 寛', '山田');
console. log( mem. getName()); // 結果： 山田 祥 寛
		</code>
	</pre>
	<p style="color: blue;">動的にメソッドを追加する。</p>
	<img src="\pleiades\2022-09\workspace\ServeletProject2\protoTypeclassBase.jpg" width="390px" width="340px">
	<p>Java の よう な クラス ベース の オブジェクト 指向 に 慣れ た 方 なら ば、「 同一 の クラス を 元 に 生成 さ れ た インスタンス は 同一 の メンバー を 持つ」 のが 常識 です が、
		プロトタイプ ベース の オブジェクト 指向（ JavaScript） の 世界 では、 同一 の クラス を 元 に 生成 さ れ た インスタンス で あっ ても、 それぞれ が 持つ メンバー は 同一 で ある とは
		限ら ない という こと です。 ここ では、 新た に メンバー を 追加 し て いる だけ です が、 delete 演算子（ 2. 4. 6 項） で インスタンス から 既存 の メンバー を 削除 する こと も
		でき ます。 この よう な ゆる さが、 本章 の 冒頭 で、 プロトタイプ が「 より 縛り の 弱い クラス の よう な もの」 と 述べ た 理由 です。 </p>
	<pre>
		<code>
var Member = function (firstName, lastName{
this.firstName = firstName;
this.lastName = lastName; };

var mem = new Member(' 祥 寛', '山田');
mem. getName = function() {
return this. lastName + ' ' + this. firstName;
}
console. log( mem. getName()); // 結果： 山田 祥 寛
		</code>
	</pre>





</body>


</html>