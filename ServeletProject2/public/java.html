<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<!-- Highlight.js -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/vs.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<!-- main.js -->
	<script type="text/javascript" src="main.js" defer></script>
	<!-- css -->
	<link rel="stylesheet" href="styles.css">
	<!--fontawesome link for drop navigation bar  -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<!--CDN animation  -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />

	<title>Java Turtorial</title>
</head>

<body>
	<div class="topnav" id="myTopnav">
		<a href="index.html" class="active">Home</a>
		<a href="index.html" class="active">Javascript</a>
		<a href="mysql_turtorial.html">MySQL</a>
		<a href="dom.html">DOM</a>
		<a href="java.html">Java</a>
		<a href="jsp.html">JSP</a>
		<a href="servlet.html">Servlet</a>
		<a href="about.html">About</a>
		<a href="javascript:void(0);" class="icon" onclick="myFunction()">
			<i class="fa fa-bars"></i>
		</a>
	</div>
	<form id="language">
		<select name="select">
			<option value="index.html" selected>日本語</option>
			<option value="index-english.html">English</option>
		</select>
	</form>
	 
		<h1>Java Turtorial</h1>
	<div class="header_image">
	<img src="\pleiades\2022-09\workspace\ServeletProject2\headerIMG.jpg" alt="img"  width="390px"height="320px">
	</div>
	<p>特にわからなかったところ</p>
	<ol>
		<li><a href="https://teratail.com/questions/284516"> なぜ引数戻り値は必要なのか</a></li>
		<li><a href="https://www.tech-teacher.jp/blog/java-static/">【初心者向け】Javaのstaticメソッド・static変数について解説！</a></li>
		<li><a href="https://teratail.com/questions/13203">【staticなmethodのメリットとは</a></li>
		<li><a href="https://camp.trainocate.co.jp/magazine/java-regular-expressions/">正規表現</a></li>
		<li><a href="https://style.potepan.com/articles/27761.html#:~:text=Object%E5%9E%8B%E3%81%A8%E3%81%AF%E3%80%81Java,%E7%B6%99%E6%89%BF%E5%85%83%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82">[Java]object型は全てのクラスの祖先！object型の型比較などを詳しく解説</a></li>
		<li><a href="https://qiita.com/aiko_han/items/e8ddce85188970fd77da">なぜ抽象クラス(Abstract)を実装するのか</a></li>
		<li><a href="https://qiita.com/RYO-4947123/items/eaeb48b6fcf97c02710f">なぜアップキャストは安全で、ダウンキャストは危険なのか</a></li>
		<li><a href="https://qiita.com/pebblip/items/1206f866980f2ff91e77">Java ジェネリクスのポイント</a></li>
		<li><a href="https://www.zunouissiki.com/entry/2018/05/20/071155/">【Java入門】ジェネリクス(総称型)と型推論</a></li>
		<li><a href="https://qiita.com/yoshi389111/items/7ea0f9b9483b0138ecdf">[Java] Mapのメモ</a></li>
		<li><a href="https://qiita.com/yoshi389111/items/c24f8beefb7b96cad921">[Java] Iteratorのメモ</a></li>
		<li><a href="https://camp.trainocate.co.jp/magazine/java-interface-abstract/#:~:text=%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%82%A4%E3%82%B9%E3%81%AF%E3%80%81%E3%81%9D%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%82%A4%E3%82%B9%E5%86%85,%E3%81%AE%E7%99%BA%E7%94%9F%E3%82%92%E9%98%B2%E3%81%92%E3%81%BE%E3%81%99%E3%80%82">Javaのinterfaceとは？インターフェースの使い方やabstractクラスとの違い</a></li>
		<li><a href="https://qiita.com/atsuk0r0/items/8d6e4b57821817b65bd0">Java Mapの使い方</a></li>
		<li><a href="https://qiita.com/Kujiro/items/e3ed881567b0d0f5e875#:~:text=%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A8%E3%81%AF%E3%80%81%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF,%E6%A7%8B%E7%AF%89%E3%81%97%E3%81%A6%E3%81%84%E3%81%8F%E6%89%8B%E6%B3%95%E3%80%82">本当のオブジェクト指向の話をしよう</a>
		<li><a href="https://qiita.com/ts7i/items/d7f6c1cd5a14e55943d4">段階的に理解する Java 例外処理</a></li>
		<li><a href="https://qiita.com/tip1t/items/b2f8e39d7cc23ad505f9">オブジェクト指向が5000%理解できる記事</a></li>
		<li><a href="https://qiita.com/GleamingCake/items/2b325d189a166ca4f88e">全部 public じゃなんでダメなの？</a></li>
		<li><a href="https://medium-company.com/%E3%83%87%E3%82%A3%E3%83%BC%E3%83%97%E3%82%B3%E3%83%94%E3%83%BC%E3%81%A8%E3%82%B7%E3%83%A3%E3%83%AD%E3%83%BC%E3%82%B3%E3%83%94%E3%83%BC%E3%81%AE%E9%81%95%E3%81%84/">ディープコピーシャローコピーの違い</a></li>
		<li><a href="https://cyzennt.co.jp/blog/2020/01/24/java%EF%BC%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%B8%AD%E8%BA%AB%E3%82%92%E3%82%B3%E3%83%94%E3%83%BC%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95%EF%BC%88clone%E3%83%A1%E3%82%BD/">java：オブジェクトの中身をコピーする方法（cloneメソッド実装）</a></li>
	</ol>
<h3>型</h3>
<pre>
<code>
Char型は一つの文字しか扱えない。文字はシングルクオテーションで囲む。
char x = 'a';
System.out.println(x); //expected a
String型は文字列を扱う。ダブルクオーテーションで囲む。
String name = "Yamada Tanaka";
System.out.println(name);

</code>
</pre>
<h3>「クラス」</h3>	
<p>フィールドとメソッドから成り立っています。フィールドは、メンバ変数ともよばれ、変数などを保存する場所です。データを格納する場所と覚えておくといい。メソッドはある機能を持たせると思ってください。命令や処理の記述をすると覚えておくと良い。</p>

<h3>「インスタンス」</h3>
<p>よくインスタンスはタイ焼きだ。とか言われます。クラスはプログラムの部品のテンプレートであり、インスタンスはテンプレートから作った実際の部品。タイ焼きの型とタイ焼きです。タイ焼きの型だけあってもダメですよね？まず生地（クラス）を作って、次に、あんこやカスタード（クラス）などを入れます。そしてその型にいれて作ったら、タイ焼き（インスタンス生成）の完成です。こちらはオブジェクト指向を参考にしてください。</p>
<h3>「演算子」</h3>
<pre>
<code>

演算子

public class Turtorial{
public static void main(String[] args) {
  int a;
  int b = 123;
  int c = 134;
  
  sum
  a = b + c;
  System.out.println(a);
  substract
  a = b - c;
  System.out.println(a);
  times
  a = b * c;
  System.out.println(a);
  divide
  a = b / c;
  System.out.println(a);
  remainder
  a = b % c;
  System.out.println(a);
  
	}
}
</code>
</pre>


<h3>「キャスト演算」</h3>
<p>型を強制的に変換させるということ。しかしキャストを用いて変換できない型が存在する。</p>
<h3>「エスケープ文字」</h3>
<p>バックスラッシュ + n で改行ができる。　\n </p>
<h3>「スタティック」</h3>
<p>インスタンスの生成なしでメソッドを書きたい場合、に有効活用するのが最大のメリット</p>
<h3>「変数」</h3>
<p>ABCとabcは違う。</p>
<h3>「for文　繰り返し文　ループ処理」</h3>
<ul>
<li>何度も同じことを繰り返す処理を行うことをループ処理、繰り返し文といいます。</li>
<li>For文には 初期化式　int i = 0;</li>
<li>継続条件式　i&lt; 5</li>
<li> 変化式　i++ </li>
<li> があって、それをfor(int i=0; i &lt; 5 i++)のように書く！ </li>
</ul>
<pre>
<code>
int型の値を４個まとめて格納できる配列。不正解→newがなかった。
int[] points = new {10,20,30,40};
double[] weights = new {1,2,3,4,5};
boolean[] answers = new  {true, true, false};
String[] names = new {"taro", "Yukari", "Liwei", "John", "Miki"};


public class Turtorial {
	public static void main (String[] args) {
    int[] moneylist = {121902, 8302, 53100};
    System.out.println("Here is your money list.");
    for(int i = 0; i &lt; moneylist.length; i++) {
    	System.out.println(moneylist[i]);
    }
	}
}

拡張for文
public class Turtorial {
 public static void main (String[] args) {
  int[] moneylist = {121902, 8302, 53100};
  System.out.println("Here is your money list.");
  for(int value :  moneylist ) {
  	System.out.println(value);
  }
  }
}

public class Turtorial {
 public static void main (String[] args) {
  int[] numbers = {3,4,9};
  System.out.println("type a single digit number");
  int input = new java.util.Scanner(System.in).nextInt();
  for (int i = 0; i < numbers.length; i++) {
  	if ( i == input) {
  		System.out.println("CORRECT!");
  	}
  }
  	
  
  
 }
}

for文をつかって配列を扱う。

public class Turtorial {
	public static void main(String[] args) {
		int[] numbers = {10, 20, 30, 40, 50};
		for(int i = 0; i < 5; i++) {
			
			System.out.println (numbers[i]);
		}
	}
}

 拡張for文

public class Turtorial {
	public static void main (String[] args) {
		int[] numbers = {10, 20, 30, 40, 50};
		for( int value : numbers ) {
			System.out.println(value);
		}
	}
}

</code>
</pre>
<h3>「while文　繰り返し文　ループ処理」</h3>
<p>while文は初めに条件式が読み込まれる（これを前判定という。）のでfalseだった場合は繰り返し処理は行われず終了。trueだった場合のみ繰り返し処理が行われる。</p>
<p>dowhile文の時は必ず一回はループ処理が実行される。そのあとに条件式をみて条件を判断する。（これを後判定という。）条件がtrueならば終了、falseならばdo継続する。<p>
<pre>
<code>
//while 文

public class Turtorial {
public static void main(String[] args) {
int temp = 23;
while (temp > 20) {
temp--;
System.out.println("ただ今の気温は" + temp + "度です。");
System.out.println("温度をさらに一度下げます。");
if (temp == 20) {
System.out.println("ただ今気温は設定値" + temp + "度に達しました。");
System.out.println("エアコンを止めます。");
break;
	}

}

}
}

//doWhile文
public class Main {
public static void main(String[] args) {

int i = 0;

do {
	i++;
	System.out.println(i);
} while (i &lt; 5);

	}
}

//さいころーゲーム　6が出るまで回り続けます。
int number = (int) (Math.random() * 6) + 1;
int count = 0;
while (number != 6) {
number = (int) (Math.random() * 6) + 1;
System.out.println("Your number is : " + number);

count++;
}
System.out.println("You got the number ***6***");
System.out.println("You got 6 untill you had " + count + " times");
</code>
</pre>
<h3>「for文while文違い」</h3>
<ol>
<li>for文は内側で変数iに値を代入するため外側からその変数は使えないこと。</li>
<li>一方でwhile文は変数iを外側で宣言するため以後変数iを再宣言することはできない。</li>
<li>for文は式と変数iが（）内にあるので直感的に見たときにわかりやすい。</li>
<li>あらかじめ始まり終わりの数字が明確になっているとき。（例：配列、List）→for while -> 繰り返しが決まっていない処理ファイルから何かをよみとったりするとき。</li>
</ol>
<h3>「for文入れ子」</h3>
<p>初期化式に変数はそれぞれ違わなければ機能しない。外側のfor文が123と繰り返す。内側のfor文も123と繰り返す。</p>
<pre>
<code>
public class Main {
public static void main(String[] args) {

for (int i = 1; i &lt;= 3; i++) {
for (int j = 1; j &lt;= 3; j++) {
System.out.println(j);
}
}

}
} //expected 1,2,3,1,2,3,1,2,3
</code>
</pre>

<h3>「条件分岐 if文」</h3>
<ul>
<li>If文の入れ子elseのあとにif-else文を再び書く。</li>
<li>IF文が一文の時であれば省略できます。</li>
</ul>
<pre>
<code>
public class Turtorial {
	public static void main(String[] args) {
    boolean weather = true;
    int tempature = -7;
    
    /^(?=.*weather = true)(?=.*tempature >= 0)/
    if ((weather = true) && (tempature >= 0)) {
    	System.out.println("You should hike the mountain!");
    } else {
    	System.out.println("Sorry, but, I don't recommend you to hike the mountain today.");
    }
	}
}
 IF文
public void weather (String[] args) {
	boolean weather = true;
	if (weather == true) {
		System.out.println("I am going to wash my clothing");
	
		
	} else {
		System.out.println("I am going to watch Netflix");
	}
}
 IF文入れ子
 int price  = 2200;
 double discount = 0 ;
 
 if(price &lt;= 1000) {
	discout = 0.1; //1000\以下なら10％引き //trueであればここが表示される。
}else {
	 //falseであればここが表示
	if(price &lt;= 2000) {
		//falseの中でもtrueだったらここが表示
		discount = 0.2; //1000\～2000円以下なら20％引き
	} else {
		//falseの中でもfalseだったらここが表示
		discount = 0.3 // 2000\を超えるなら30％引き
	}
}

price = (int)(price * (1.0 -disscount));

System.out.println(price);

//例題1　IF文省略前　
if(price &lt;= 2000) {
		discount = 0.2;
	}
//例題1　IF文省略後
//IF文省略は鍵括弧()を外します。一文の時にしかできません。
if(price > 1000) discount = 0.2;

//例題2　IF文省略前
if(price >= 1000) {
	discount = 0.2;
}else {
	discount = 0.1;
}
//例題2IF文省略後
if(price >= 1000) discount = 0.2;
else discount = 0.1;
</code>
</pre>
<h3>「条件演算子」</h3>
<p>If文のような処理を短く書くための処理　初めの括弧()の中にBoolean式を書く。trueならばコロン左、falseならばコロン右。</p>
<pre>
<code>
//IF文省略前
int price = 100;
double discount;
 
 if(price>= 1000) {
	double discount = 0.2;
}else {
	double discount = 0;
}
//条件演算子　IF文省略後
int price = 100;
double discount = (price >= 1000) ? 0.2 : 0;
</code>
</pre>
<h3>「Switch文」</h3>
<ul>
<li>IF文は括弧（）の中がTrueFalseのBooleanだった条件分岐に対して、Switchは値が0、1、2だった場合の処理を書く。</li>
<li>「変数＝＝値」「変数＝＝変数」のような左辺と右辺が一致するかを比較する式であり、それ以外の「＞」や「＜」「！＝」は使われていない。</li>
<li>Breakを書かないとcase2,3,4と処理を行ってしまう。</li>
<li>逆にケース1、ケース２だった場合にといった処理をあえてBreakを書かずに記述できる。</li>
</ul>

<pre>
<code>
スイッチ文
public static void nextline (String[] args)  {
	System.out.println("[menu] 1:research 2:register 3 :delete 4:update");
	int number = new java.util.Scanner(System.in).nextInt();
	switch (number) {
	case 1: 
		System.out.println("I am going to research");
		break;
	case 2:
		System.out.println("I would like to reaserch");
		break;
	case 3: 
		System.out.println("No, I would like to delete.");
		break;
	case 4:
		System.out.println("Yes, I would like to update");
		break;
	default:
		break;
	}
</code>		
</pre>
<h3>break文</h3>
<ul>
<li>break文は処理を中断し繰り返し文を抜けることができる。</li>
<li>if文と組み合わせることである条件を満たしたら繰り返し処理を抜けたい場合に使用する。</li>
</ul>
<pre>
<code>
for (int i = 0; i < 10; i++) {
System.out.println(i);
if (i == 6) {
	System.out.println("NO7");
	break;
}

}
System.out.println("done counting");

//expected 1,2,3,4,5,6,NO7,done counting
</code>
</pre>
<h3>continue文</h3>
<ul>
<li>繰り返し処理を中断し、次の繰り返し処理に移る機能を持つ。</li>
<li>if文と組み合わせることである条件を満たしたら繰り返し処理を抜けたい場合に使用する。</li>
</ul>
<pre>
<code>
for (int i = 0; i < 10; i++) {
System.out.println(i);
if (i == 6) {
System.out.println("hello");
continue;
}

}

//expected 1,2,3,4,5,6,hello,7,8,9
</code>
</pre>
<h3>ラベル</h3>
<ul>
<li>ループがネスト（入れ子）されている状況だけでなく外側のループも抜けたいようなときはラベルを使う。</li>
<li>ラベルは中断継続したいループ処理に「ラベル名:」を付けると使用できる。</li>
<li>ラベル名はなんでもいい。</li>
</ul>
<pre>
<code>
int[][] apartmentNumbers = { { 101, 102, 103 }, { 201, 202, 203 }, { 301, 302, 303 } };
//ラベル文
LABEL: for (int i = 0; i < 3; i++) {
for (int j = 0; j < 3; j++) {
System.out.println(apartmentNumbers[i][j]);

if (apartmentNumbers[i][j] == 202) {
System.out.println("it is the second floor.");
//ラベル名追加　こちらはbreak文ですがcontinue文でも可能です。
break LABEL;
}

}

}
System.out.println("The package has been delivered");
</code>
</pre>
<h3>「IF文Switch文違い？」</h3>
<p>条件指定がtrue/falseだった場合はif文、変数の値によって条件分岐する場合はswitch文。if文を使用してswitch文を書くことは可能だが、else ifをたくさん書くことになるので、コードが複雑になり、その分処理速度が遅くなる。</p>
<h3>「なぜメソッドを使うのか」</h3>
<p>プログラム全体がきれいに見える。あとからみやすくなる。同じ処理を再利用できる。修正がきく。</p>
<h3>「配列」</h3>
<p>配列はfor文とセットで使われることが多い。配列は箱の中にものを入れている感じをイメージするといい。配列の各要素にループ処理で一つずつ利用する。</p>
<pre>
<code>
public class Main {
	public static void main(String[] args) {
		int[] numbers = { 1, 2, 3, 5, 6, 7, 8, };

		for (int i = 0; i &lt; numbers.length; i++) {
			System.out.println(numbers[i]);
		}

	}
}
</code>
</pre>
<h3>多次元配列</h3>
<p>箱の中身を整理して入れるように多次元配列を使うと箱の中身が整理される。</p>
<pre>
<code>
int rooms[][] = { { 100, 101, 102 }, { 201, 202, 203 }, { 301, 302, 303 } };

System.out.println(rooms[0][2]);
System.out.println(rooms[2][2]);
System.out.println(rooms.length);
System.out.println(rooms[2].length);
System.out.println("------------------------------------------");
for (int i = 0; i &lt; rooms.length; i++) {
	for (int j = 0; j &lt; rooms[0].length; j++) {
		System.out.println(rooms[i][j]);
	}
}


//文字列の表示方法　another example 
String[][] animals = {
{ "Akita Ken", "Hachiko, the adorable pup whose legacy lives on as a Japanese dog statue in Shibuya",
"Akita Prefecture" },
{ "Hokkaiido Inu",
"Thought to have an older bloodline among the Japanese dogs, they have a thicker outer coat, larger paws, and smaller ears.",
"Hokkaido" },
{ "Kai Ken",
"The Kai Ken is one of the most distinctive of the original Japanese dog breeds; nicknamed the \"tiger dog\" from their coat colors.",
"Yamanashi" },
{ "Kishu Inu",
"A hunting dog that's still relatively rare even in Japan, they are intelligent, brave and independent, but also quite impulsive.",
"Kyushu" },
{ "Shikoku Ken",
"The Shikoku Ken is a beautiful Japanese spitz-type breed with a wolf-like appearance.",
"Shikoku" } };

for (int i = 0; i &lt; animals.length; i++) {
for (int j = 0; j &lt; animals[0].length; j++) {

System.out.println(animals[i][j]);
	}
}
</code>
</pre>
<h3>「なぜクラスをつくるのか」</h3>
<p>部品化するため。。車を作るにはドアを作る人、タイヤを作る人、塗装をする人などに分かれていて、これに似たようなこと。こちらについてはオブジェクト指向にてまた触れる。</p>
<h3>なぜクラスやメソッドに分ける？</h3>
<ul>
<li>短くまとまったコードの方が見やすい。わかりやすい。</li>
<li>一度書いたソースコードを何度でも使いまわせる。</li>
<li>使うクラスだけをインスタンス化することでメモリ節約でき、処理スピードがあがる。</li>
<li>どのプログラムがどこに書かれているか、誰がいつどのような背景で書いたかなど、情報の管理や特定ができる。</li>
<li>変更が必要なクラスやメソッドのみを修正すればよい。（メンテナンス性）</li>
</ul>
<h3>「なぜ引数戻り値は必要なのか」</h3>
<p>x+yとしておくことで外部からのアクセスが可能になる。５＋１であれば、再利用もできなく重複してしまう。<a href= "https://teratail.com/questions/284516<">個々のウェブサイトによると</a>　そもそも「なぜ戻り値は必要なのか？」という考えではなく、その逆の思考「メソッドにどんな機能を持たせたいのか」を考えることが最も重要と書かれていました。
<pre>
<code>
引数の例
public class Turtorial {
	public static void main(String[] args) {
		System.out.println("メソッドを呼び出します。");
		hello("Kaede");
		hello("Naoka");
		hello("Sumire");
		System.out.println("It is done by calling the method.");
	}
	public static void hello(String name) {
		System.out.println( "Hello" + name + "-san");
	}
}

引数の例（渡す値が複数の場合）
public class Turtorial {
	public static void main(String[] args) {
		add(199,29);
		add(288,47);
	}
	複数の値を受け取るaddメソッド
	public static void add(int x, int y) {
		int ans = x + y;
		System.out.println(x + "+" + y + "=" + ans );
	}
}

戻り値の例
public class Turtorial {
	public static int add(int x, int y) {
		int ans = x + y;
		return ans;
	}
	public static void main(String[] args) {
		int ans = add(100,19);
		System.out.println("100 + 19 =" + ans);
	}
}


引数に配列を受け取るメソッドの利用
public class Turtorial {
	int型配列を受け取り、すべての要素を表示するメソッド
	public static void printArray(int[] array) {
		for (int element : array) {
			System.out.println(element);
		}
	}
	public static void main(String[] args) {
		int[] array = {1, 2, 3};
		配列を渡す。
		printArray(array); 
	}
}

おなじ配列を参照していることを確認する。
public class Turtorial {
	public static void incArray(int[] array) {
      配列の長さを取得するには length フィールドの値を参照します。配列の長さとは配列に含まれる要素の数です。
      for(int i = 0; i &lt; array.length; i++) {
      	array[i]++;
		}
	}
	public static void main(String[] args) {
       int[] array = {1,2,3};
       incArray(array);
       for (int i : array) {
       	System.out.println(i);
       }
	}
}

戻り値が配列の場合 makearray(3)でアドレスを作っている.newArrayでも新しい住所を作っている。
同時にまじわるところから、数がカウントされる。
public class Turtorial {
	public static int[] makeArray(int size) {
      int[] newArray = new int[size];
      for(int i = 0; i &lt;newArray.length; i++) {
      	newArray[i] = i;
      }
		return newArray;
	}
	public static void main(String[] args) {
		int[] array = makeArray(3);
		for(int i : array ) {
			System.out.println(i);
		}
	}
}


public class Hero {
	public static void email(String name) {
		System.out.println(name);
	}

	public static String add(String x) {
		return x;
	}

	public static void main(String[] args) {
		System.out.println("this is the message for you.");
		email("tittle");
		email("content");
		email("Bye");
		System.out.println("Regards, XXX");

	}

}

</code>
</pre>
<h3>可変長引数</h3>
<p>引数の数が決まっていない引数、型が同じだとどんな数の引数でも当てはめることができる。</p>
<pre>
<code>
public class Main {

	static void number(int... numbers) {
		for (int num : numbers) {

			System.out.println(num);
		}

	}

	public static void main(String[] args) {

		number(4, 5, 6, 7);
}
</code>
</pre>
<h3>メソッドのオーバーロード</h3>
<p>同じ名前のメソッドを作り引数が違う場合オーバーロード可能。</p>
<ul>
<li>同じ名前同じ引き数はエラーになる。</li>
</ul>

<pre>
<code>
引数の型が異なる場合；オーバーロード
public class Turtorial{
	public static int add(int x, int y) {
		return x + y;
	}
	public static double add(double x, double y) {
		return x + y;
	}
	public static String add(String x, String y) {
		return x + y;
	}
	public static void main(String[] args) {
		System.out.println(add(19,20));
		System.out.println(add(2.4, 3.4));
		System.out.println(add("Hello","DisneyLand!"));
	}
}

引数の型が異なる場合；オーバーロード

public class Turtorial {
	public static int add(int x, int y) {
		return x + y;
	}
	public static int add(int x, int y, int z) {
		return x + y + z;
	}
	public static void main(String[] args) {
		System.out.println("10+20="+ add( 10, 20) );
		System.out.println("30+40+50=" + add(30,40,50));
		
	}
}

//引数が違うところに注目
public class Turtorial {
	public static String add(String x, String y) {
		return x + y;
	}
	public static int add(int x, int y) {
		return x + y; 
	}
	
	public static double add(double x, double y) {
		return x + y;
	}
	 
	public static void greeting(String name){
		System.out.println("Hello" + name);
	}
	public static void main (String[] args) {
		System.out.println(add ("Hello", "Aoki"));
		System.out.println(add(3, 4));
		System.out.println(add(1.2, 1.5));
		greeting("Takashi");
	}
</code>
</pre>


<h3>「コンストラクタはなぜあるのか」</h3>
<ul>
<li> Construct Construction 組み立てることです。</li>
<li> オブジェクトを構築するもの。</li>
<li>コンストラクタを作った場合インスタンス化する際に引数にあった値を入れなければエラーになる。</li>

</ul>
<p>
インスタンスの初期値を操ることができるから。しかしどのようなときに使うのか？については一つのインスタンスに対して複数の引数を指定したいときとしか考えつくことがありません。引数が違うのであれば、コンストラクタをオーバーロードすることは可能。
</p>
<p>コンストラクタのルール定義</p>
<ul>
<li>コンストラクタの定義において戻り値の情報は何も記述しない</li>
<li> コンストラクタ名はクラス名と同じ</li>
<li>インスタンス生成時必ず最初に呼び出される。</li>
<li>インスタンス生成時は「＝」の右側がコンストラクタになる。</li>
</ul>
<pre>
<code>
public class Main {
//三角形の面積を求める。
//これがコンストラクタ
public static int add(int x, int y) {
int calcTriangleArea = x * y / 2;
return calcTriangleArea;

}

//円の直径を求める。
//これがコンストラクタ
public static int add(double z) {
int calcCircleArea = (int) (z * z);
return calcCircleArea;
}

public static void main(String[] args) {
//メソッドをオーバーライドしている。引数が違うから計算も違う。

//int calcTriangleArea = add(2,3);
//int calcCircleArea = add(2.2);
System.out.println(add(2, 3));
System.out.println(add(2.2));
}
}
</code>
</pre>

<h3>「=＝とequal違い」</h3>
<p>
String foo = "Apple" String bar = "Apple" if(foo == bar)の場合＝＝はオブジェクトが同じかどうかをはんていするのでTrueになる。メモリの参照先が同じかどうかを判定するしたい場合は、equalsを使う。ですので、「文字列の時にはequalsを使うと良い」。参照先とは一種の住所。アパートメント自体の住所（"Orange"）は同じだとしても部屋番号（"Orange" : 101, "Orange" : 102）は異なります。参照先が違うため、コンピューターは違う値とみなす。
</p>
<h3>クローン　ディープコピー　シャローコピー</h3>
<p>クローンを使うとディープコピーできる。データを含めたオブジェクトをコピーできる。</p>
<ul>
<li>シャローコピー：＝でだいにゅうするだけだと参照先だけがコピーされる。</li>
<li>シャローコピー：コピー先の変更がコピー元に影響する恐れがかなり高い。</li>
<li>ディープコピー：これを避けるためにクローンを使って中身ごとコピーする必要がある。</li>
<li><a href="https://cyzennt.co.jp/blog/2020/01/24/java%EF%BC%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E4%B8%AD%E8%BA%AB%E3%82%92%E3%82%B3%E3%83%94%E3%83%BC%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95%EF%BC%88clone%E3%83%A1%E3%82%BD/">java：オブジェクトの中身をコピーする方法（cloneメソッド実装）</a></li>

</ul>
<p><a href="https://medium-company.com/%E3%83%87%E3%82%A3%E3%83%BC%E3%83%97%E3%82%B3%E3%83%94%E3%83%BC%E3%81%A8%E3%82%B7%E3%83%A3%E3%83%AD%E3%83%BC%E3%82%B3%E3%83%94%E3%83%BC%E3%81%AE%E9%81%95%E3%81%84/">ディープコピーシャローコピーの違い</a>についてはこれを読めばわかりやすい。</p>

<pre>
<code>
public class CloneableItem implements Cloneable {

// イミュータブルではない参照型変数を含む場合はそれも一緒にcloneが必要
// （今回は割愛）
private int itemNumber;
private String itemWeapon;

public int getItemNumber() {
	return itemNumber;
}

public void setItemNumber(int itemNumber) {
	this.itemNumber = itemNumber;
}

public String getItemWeapon() {
	return itemWeapon;
}

public void setItemWeapon(String itemWeapon) {
	this.itemWeapon = itemWeapon;
}

// Cloneableインターフェースのclone()メソッドをオーバーライド
@Override
public CloneableItem clone() {
	CloneableItem clonedItem = null;
	// CloneNotSupportedExceptionを返す可能性があるので例外処理が必要
	try {
		// Object型で返ってくるのでキャストが必要
		clonedItem = (CloneableItem) super.clone();
	} catch (CloneNotSupportedException e) {
		e.printStackTrace();
	}
	return clonedItem;
}

}


public class ItemCloneMain {
	public static void main(String[] args) {

//シャローコピー
System.out.println("［参照先のみコピーした場合］");
CloneableItem cloneableItem1 = new CloneableItem();
cloneableItem1.setItemNumber(1);
cloneableItem1.setItemWeapon("sword");
System.out.println("コピー前のコピー元オブジェクト：ID=" +
		cloneableItem1.getItemNumber() +
		" NAME=" +
		cloneableItem1.getItemWeapon());
CloneableItem cloneableItem2 = cloneableItem1;
System.out.println("コピー後のコピー元オブジェクト：ID=" +
		cloneableItem1.getItemNumber() +
		" NAME=" +
		cloneableItem1.getItemWeapon());
System.out.println("コピー後のコピー先オブジェクト：ID=" +
		cloneableItem2.getItemNumber() +
		" NAME=" +
		cloneableItem2.getItemWeapon());
cloneableItem2.setItemNumber(2);
cloneableItem2.setItemWeapon("shield");
System.out.println("編集後のコピー元オブジェクト　：ID=" +
		cloneableItem1.getItemNumber() +
		" NAME=" +
		cloneableItem1.getItemWeapon());
System.out.println("編集後のコピー先オブジェクト　：ID=" +
		cloneableItem2.getItemNumber() +
		" NAME=" +
		cloneableItem2.getItemWeapon());
//ディープコピー
System.out.println("");
System.out.println("［cloneで中身をコピーした場合］");
CloneableItem cloneableItem3 = new CloneableItem();
cloneableItem3.setItemNumber(3);
cloneableItem3.setItemWeapon("armor");
System.out.println("コピー前のコピー元オブジェクト：ID=" +
		cloneableItem3.getItemNumber() +
		" NAME=" +
		cloneableItem3.getItemWeapon());
CloneableItem cloneableItem4 = cloneableItem3.clone();
System.out.println("コピー後のコピー元オブジェクト：ID=" +
		cloneableItem3.getItemNumber() +
		" NAME=" +
		cloneableItem3.getItemWeapon());
System.out.println("コピー後のコピー先オブジェクト：ID=" +
		cloneableItem4.getItemNumber() +
		" NAME=" +
		cloneableItem4.getItemWeapon());
cloneableItem4.setItemNumber(4);
cloneableItem4.setItemWeapon("helm");
System.out.println("編集後のコピー元オブジェクト　：ID=" +
		cloneableItem3.getItemNumber() +
		" NAME=" +
		cloneableItem3.getItemWeapon());
System.out.println("編集後のコピー先オブジェクト　：ID=" +
		cloneableItem4.getItemNumber() +
		" NAME=" +
		cloneableItem4.getItemWeapon());

	}
}
</code>
</pre>
<h3>「正規表現」</h3>
<p>
郵便番号、携帯番号、数字チェック、英数字チェック、日付、メールアドレス、URLを特定する正規表現
<a href="https://camp.trainocate.co.jp/magazine/java-regular-expressions/" >こちらを参照</a>
</p>

<p style="color:blue">正規表現における代表的なメタ文字</p>
<table id="tbl75c" class="cmsTable cmsTableC cmsTable75">
<caption></caption>
<thead><tr>
<th id="null" width="30%">正規表現</th>
<th id="null">概要</th>
</tr></thead><tbody><tr>
<th id="null">.</th>
<td id="null">何か一文字</td>
</tr><tr>
<th id="null">|</th>
<td id="null">または（or条件）</td>
</tr><tr>
<th id="null">*</th>
<td id="null">左の文字の繰り返し(0文字以上)</td>
</tr><tr>
<th id="null">+</th>
<td id="null">左の文字の繰り返し(1文字以上)</td>
</tr><tr>
<th id="null">?</th>
<td id="null">左の文字の繰り返し(0文字以上1文字)</td>
</tr><tr>
<th id="null">{数値}</th>
<td id="null">左の文字を繰り返し（指定数回）</td>
</tr><tr>
<th id="null">{数値A,数値B}</th>
<td id="null">左の文字を繰り返し(A回以上B回以下)</td>
</tr><tr>
<th id="null">{数値,｝</th>
<td id="null">左の文字を繰り返し(指定数回以上)</td>
</tr><tr>
<th id="null">^</th>
<td id="null">前方一致</td>
</tr><tr>
<th id="null">$</th>
<td id="null">後方一致</td>
</tr><tr>
<th id="null">\　バックスラッシュ</th>
<td id="null">エスケープ</td>
</tr><tr>
</tr></tbody>
<tfoot><tr><td colspan="2"></td></tr></tfoot>
</table>


<p style="color:blue">文字セット・文字レンジ</p>
<table id="tbl75c" class="cmsTable cmsTableC cmsTable75">
<caption></caption>
<thead><tr>
<th id="null" width="30%">正規表現</th>
<th id="null">概要</th>
</tr></thead><tbody><tr>
<th id="null">{文字}</th>
<td id="null">指定文字に一致する１文字</td>
</tr><tr>
<th id="null">[文字A文字B]</th>
<td id="null">AかBに一致する一文字</td>
</tr><tr>
<th id="null">[文字A-文字B]</th>
<td id="null">文字レンジに一致する１文字</td>
</tr><tr>
<th id="null">ルールに一致しない１文字</th>
<td id="null">[^]</td>
</tr><tr>
</tr></tbody>
<tfoot><tr><td colspan="2"></td></tr></tfoot>
</table>
<p style="color:blue">文字レンジの使用例</p>
<table id="tbl75c" class="cmsTable cmsTableC cmsTable75">
<caption></caption>
<thead><tr>
<th id="null" width="30%">正規表現</th>
<th id="null">概要</th>
</tr></thead><tbody><tr>
<th id="null">{0-9a-zA-Z}</th>
<td id="null">半角英数</td>
</tr><tr>
<th id="null">[!-~]</th>
<td id="null">半角英数記号（半角スペースを除く）</td>
</tr><tr>
<th id="null">[!-/:-@[-`{-~]</th>
<td id="null">半角記号（半角スペースを除く）「[」の後ろに\エスケープシーケンス忘れずに</td>
</tr><tr>
<th id="null">[ぁ-んー]</th>
<td id="null">全角ひらがな</td>
</tr><tr>
<th id="null">[ァ-ンヴー]</th>
<td id="null">全角カタカナ</td>
</tr><tr>
</tr></tbody>
<tfoot><tr><td colspan="2"></td></tr></tfoot>
</table>
<p style="color:blue">チートシート</p>
<table id="tbl75c" class="cmsTable cmsTableC cmsTable75">
<caption></caption>
<thead><tr>
<th id="null" width="30%">正規表現</th>
<th id="null">概要</th>
</tr></thead><tbody><tr>
<th id="null">メールアドレス</th>
<td id="null">^[a-zA-Z0-9_.-]+@([a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]*\.)+[a-zA-Z]{2,}$</td>
</tr><tr>
<th id="null">携帯電話番号</th>
<td id="null">^0[789]0-\d{4}-\d{4}$</td>
</tr><tr>
<th id="null">郵便番号</th>
<td id="null">^\d{3}-\d{4}$</td>
</tr><tr>
<th id="null"></th>
<td id="null">^\d{3}-\d{4}$</td>
</tr><tr>
<th id="null">URL</th>
<td id="null">https?://([\w-]+\.)+[\w-]+(/[\w\-./?%&=~]*)?</td>
</tr><tr>
</tr></tbody>
<tfoot><tr><td colspan="2"></td></tr></tfoot>
</table>
<p style="color:blue">正規表現における代表的なエスケープシーケンス</p>
<table id="tbl75c" class="cmsTable cmsTableC cmsTable75">
<caption></caption>
<thead><tr>
<th id="null" width="30%">正規表現</th>
<th id="null">概要</th>
</tr></thead><tbody><tr>
<th id="null">\t</th>
<td id="null">タブ</td>
</tr><tr>
<th id="null">\r</th>
<td id="null">改行（CR：カーソルを一番左へ）</td>
</tr><tr>
<th id="null">\n</th>
<td id="null">改行（LF：カーソルを一番左へ）</td>
</tr><tr>
<th id="null">\r\n</th>
<td id="null">改行（CRLF：カーソルを一番左へ）</td>
</tr><tr>
<th id="null">\f</th>
<td id="null">改ページ</td>
</tr><tr>
<th id="null">\d</th>
<td id="null">数値１文字（[0-9]）と同じ</td>
</tr><tr>
<th id="null">\D</th>
<td id="null">数値以外の一文字[^0-9]</td>
</tr><tr>
<th id="null">\s</th>
<td id="null">空白文字（半角スペース・タブ・改行・改ページ）一文字</td>
</tr><tr>
<th id="null">\S</th>
<td id="null">空白文字（半角スペース・タブ・改行・改ページ）以外の一文字</td>
</tr><tr>
<th id="null">\w</th>
<td id="null">記号や空白文字を除く文字（注意: ＿アンダーはヒットする。）</td>
</tr><tr>
<th id="null">\W</th>
<td id="null">記号や空白文字</td>
</tr><tr>
<th id="null">\0</th>
<td id="null">NULL文字</td>
</tr><tr>
</tr></tbody>
<tfoot><tr><td colspan="2"></td></tr></tfoot>
</table>
<h3>「アクセス修飾子」</h3>
<p>public</p>
<ul>
<li>
public どこからでもアクセス可能。
</li>
</ul>
<p>private</p>
<ul>
<li>
private　同じクラス内だけでしか、アクセスできない。厳密にいうと、getter/setterをつかって、アクセスはできる。デフォルトメソッドは、同じパッケージ内でしか、アクセスできない。
</li>
</ul>
<pre>
<code>
//Calculationクラス
package variables;

public class Calculation {
private double tax_rate = 1.1;

double priceIncludingTax(int price, double tax_rate) {

return price * this.tax_rate;

}

}

//Mainクラス
package variables;

public class Main {
public static void main(String[] args) {

Calculation cal = new Calculation();
//privateで1.1と固定したので1.8になっているが1.1のままで計算される。
System.out.println(cal.priceIncludingTax(1000, 1.8));
//アクセスできない。Privateは同じクラス内でしかアクセスできない。
System.out.println(cal.TAX_RATE);
	}
}


</code>
</pre>
<p>Final　定数</p>

<ul>
<li>
ファイナルはクラス、メソッド、変数に代入可能で参照先を変えたくないときに扱う。この時に定数は大文字にする。ルールである（待ち合わせ時間に遅れてはいけない的な）。プログラミング副作用を防ぐ。
</li>
</ul>
<pre>
<code>
//Calculationクラス
package variables;

public class Calculation {
final double TAX_RATE = 1.1;

double priceIncludingTax(int price, double tax_rate) {

return price * this.TAX_RATE;

	}

}

//Mainクラス
package variables;

public class Main {
public static void main(String[] args) {

Calculation cal = new Calculation();
//1.8になっていても1.1で計算される。
System.out.println(cal.priceIncludingTax(1000, 1.8));
//ファイナルの時はアクセスはできるが再度代入はできない。
System.out.println(cal.TAX_RATE);

	}
}



</code>
</pre>
<h3>「ジェネリクス」</h3>
<p>
アプリを作ってみるとこのジェネリクスをたくさん使っていた。調べてみたところ、ジェネリクスが発表される以前はキャストを頻繁に使用していたらしい。私の理解した範囲内で書きますと、ジェネリクスを使うことによってゲットで呼ぶことができその時同時に型指定もできる。このことによって、いちいち違う型のクラスを使わなくてよくなる。ArrayListのときにも、ダイヤモンド演算子として使われる。継承元のメソッドで型を定義した場合、ダイヤモンド演算子の中に、メソッド名を入れることは可能である。<a href = "https://www.zunouissiki.com/entry/2018/05/20/071155/">初心者はこちらを参考にするとよい。</a>詳細はこちら<a href="https://qiita.com/pebblip/items/1206f866980f2ff91e77">Java ジェネリクスのポイント</a>
</p>
<h3>「ArrayList」</h3>
<p>
箱の個数が決まっていないときに追加できる。<a href = "https://qiita.com/atsuk0r0/items/839d51185a11ccc9eae9">Java ArrayListについて</a>ArrayList とは、 Listインタフェース を実装した コレクションクラス である。
ArrayList は、 Array という名にあるように配列のような感覚で扱うことができる。ダイヤモンド演算子の中はラッパークラスを使う。
</p>
<table class="pro2">
<tr><th>基本データ型</th><th>ラッパークラス</th></tr>
<tr><td>boolean</td><td>Boolean</td></tr>
<tr><td>char</td><td>Character</td></tr>
<tr><td>byte</td><td>Byte</td></tr>
<tr><td>short</td><td>Short</td></tr>
<tr><td>int</td><td>Integer</td></tr>
<tr><td>long</td><td>Long</td></tr>
<tr><td>float</td><td>Float</td></tr>
<tr><td>double</td><td>Double</td></tr>
</table>
<pre>
<code>
public class Student {
//  名前
private String name;
//  学年
private int grade;
//  番号
private int number;

//  コンストラクタ
public Student(String name, int grade, int number) {
this.name = name;
this.grade = grade;
this.number = number;
}

//  名前の取得
public String getName() {
return name;
}

//  学年の取得
public int getGrade() {
return grade;
}

//  番号の取得
public int getNumber() {
return number;
}

}

public class SampleEx501 {

public static void main(String[] args) {
ArrayList&lt;Student> al = new ArrayList&lt;>();
al.add(new Student("安藤一郎", 1, 1));
al.add(new Student("伊藤花子", 1, 2));
al.add(new Student("太田たかし", 2, 3));
al.add(new Student("加藤紀子", 2, 4));
al.add(new Student("木田直美", 3, 5));
//  3番目を削除
al.remove(3);
//al.lengthではなくal.size()
for (int i = 0; i &lt; al.size(); i++) {
Student s = (Student) al.get(i); //  i番目のオブジェクトを取得
System.out.println("番号:" + s.getNumber() + " 名前: " + s.getName() + " 学年" + s.getGrade());
}

}

}
</code>
</pre>
<h3>「enum」</h3>
<p>
こちらでは、enum に複数の定数を代入し一つにまとめることができる。enumを別クラスにおいて呼び出すことで、かなりすっきりとしたこーどを書くことができる。定数が多い場合にenumで書くことによって漏れを防ぐためにある。
</p>
<pre>
<code>
public enum Fruits {
Banana("沖縄県", 1), Orange("和歌山", 1), Apple("青森", 1), Strawberry("栃木", 1), 
Blueberry("東京", 1), Rasberrry("東京",1), Pinapple("沖縄県", 1);

private String prefecture;
private int ranking;

public Fruits(String prefecture, int ranking) {
	this.prefecture = prefecture;
	this.ranking = ranking;
}

public String getPrefecture() {
	return prefecture;
}

public int getRanking() {
	return ranking;
}

}


public class Main {
public static void main(String[] args) {
for (Fruits fruits : Fruits.values()) {
	System.out.println(fruits);
}

System.out.println("::::::::::::::::");
Fruits fruits = Fruits.Apple;
System.out.println(fruits);
System.out.println(fruits.Orange.getPrefecture());
System.out.println(fruits.Orange.getRanking());

	}

}

</code>
</pre>
<h3>「配列」</h3>
<p>
箱中におもちゃを入れたとする。そのおもちゃ一個一個をすべて値として取り出せる。for文を使うとおもちゃ全部の名前が出てくる。
</p>
<pre>
<code>

//for文と配列
public class Main{
public static void main(String[] args) {
 int[] scores = {50, 40, 20, 40,70};
 for(int i=0; i &lt; scores.length; i++ ) {
 System.out.println(scores[i]);
 }
}
}

//拡張for文と配列
public class Main {
public static void main(String[] args) {
int[] scores = {50, 40, 20, 40,70};
for(int i : scores) {
System.out.println(i);
}
}
}



public class Main{
public static void main(String[] args) {
int[]  numbers;
numbers = new int[5]; //配列の要素数を決定する。
System.out.println(numbers.length);
	}
}


//配列とfor文を使って合計値と平均を出力。

public class Turtorial {
public static void main (String[] args) {
int[] scores = {20, 30, 40, 50, 80};
int sum = 0;
for (int i = 0; i &lt; scores.length; i++) {
	sum += scores[i];
}
int avg = sum / scores.length;
System.out.println("SUM" + sum );
System.out.println ("AVG" + avg);
	}
}


//1. 配列を使って数字を箱に格納。
//2. for文を使って配列を表示。
//3. IF文を使って箱のなかの50以上の数字だけを条件で指定する。
public class Turtorial {
public static void main(String[] args) {
int[] scores = {10, 30, 60, 90 ,100};
int count = 0;
for (int i = 0; i &lt; scores.length; i++);{
if (scores[i] >= 50);{
	count++;
}
}
}
}
</code>
</pre>
<h3>「Staticメソッド 」</h3>
<ul>
<li>クラス付属のフィールドやメソッドを指す。</li>
<li>クラスから直接利用可能。</li>
<li>スタティックなメソッドからはスタティックのフィールドでしか扱えない。</li>
<li>スタティック以外のオブジェクトで作られるインスタンスとスタティックフィールドは独立している。</li>
<li>逆に捉えると、インスタンスの生成なしでメソッドを書きたい場合、に有効活用するのが最大のメリット。</li>
<li> 字列処理を正したいときなどに使われることが多い。</li>
<li>インスタンスメンバは、インスタンスを生成しないといけない。</li>
</ul>
<pre>
<code>
//  静的メンバもつクラス
public class SampleClassEx01 {
private int value = 0;              //  インスタンスフィールド
private static int num = 0;         //  静的フィールド
//  コンストラクタ①　引数あり
public SampleClassEx01(int value){
    //  引数をインスタンスフィールドに代入
    this.value = value;
    //  静的メンバのインクリメント。 インスタンス化なし。
    num++;
}
//  コンストラクタ②　引数なし
public SampleClassEx01(){
    this(100);  //  引数つきコンストラクタを呼び出す
}
//  インスタンスの数を取得
public static int getNumberOfInstance(){
    return num;
}
//  インスタンスフィールドを取得
public int getValue(){
    return this.value;
}
}
</code>
</pre>
<p>インスタンスの元となるfile情報を格納しているメモリ領域をクラスオブジェクトと言い、Javaの実行の際にメモリ上に生成されます。</p>
<p>クラスオブジェクトではfile情報のほかにフィールドとメソッドを保養うすることが可能であり、フィールドをクラス変数、メソッドをクラスメソッド、合わせて静的メンバと言う。</p>
<p>Static修飾子をつけることで静的メンバとして扱う。</p>
<p>クラスオブジェクトは変数名としてクラス名が使われます。</p>
<p>インスタンス化の際に複製されない。クラスで固有全てのインスタンスで共通のものとして扱われる。</p>
<p>静的メンバは「インスタンス名.〇〇」というようにインスタンスから自身のものであるかのようにアクセスが可能。</p>
<pre>
<code>
//SettingCar.java

//abstract class 

package accessRestrictionClass;

public abstract class SettingCar {
	abstract void speed(int km);

	abstract void stop(boolean signal);

	abstract void lock();
}


//Main.java
package accessRestrictionClass;

public class Main {
	public static void main(String[] args) {
		Mercedes mercedes = new Mercedes();
		Tesla tesla = new Tesla();
		System.out.println("---------------------------------Mercedes-----------------");
		mercedes.stop(false);
		mercedes.speed(240);

		System.out.println("------------------------------tesla------------------");
		tesla.autopilot();
		///polymorphism 多態性　ポリモーフィズム
		System.out.println("------------------------polymorphism-------------------");
		SettingCar[] scar = { mercedes, tesla };
		for (int i = 0; i < scar.length; i++) {
			scar[i].lock();
		}

	}
}

//Mercedes.java
package accessRestrictionClass;

public class Mercedes extends SettingCar {

	@Override
	void speed(int km) {
		// TODO 自動生成されたメソッド・スタブ
		System.out.println("The speed is so fast " + km + " km in 3 seconds");
	}

	@Override
	void stop(boolean signal) {
		// TODO 自動生成されたメソッド・スタブ
		System.out.println("you have to stop when the signal is " + signal);
	}

	void lock() {
		System.out.println("locked");
	}

}

//Tesla.java
package accessRestrictionClass;

public class Tesla extends Mercedes {
	@Override
	void speed(int km) {
		// TODO 自動生成されたメソッド・スタブ
		System.out.println("The speed is so fast " + km + " km in 3 seconds");
	}

	@Override
	void stop(boolean signal) {
		// TODO 自動生成されたメソッド・スタブ
		System.out.println("you have to stop when the signal is " + signal);
	}

	void lock() {
		System.out.println("locked");
	}

	void autopilot() {
		System.out.println("Autopilot mode begin...");
	}

}


</code>
</pre>
 
<h3>Object指向</h3>
<a href="https://qiita.com/Kujiro/items/e3ed881567b0d0f5e875#:~:text=%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%81%A8%E3%81%AF%E3%80%81%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF,%E6%A7%8B%E7%AF%89%E3%81%97%E3%81%A6%E3%81%84%E3%81%8F%E6%89%8B%E6%B3%95%E3%80%82">本当のオブジェクト指向の話をしよう</a>
<p>タイ焼きとタイ焼きの型。タイ焼きをつくるのには、タイ焼きの型をタイ焼きを作るために作る。それを何度も繰り返し
てタイ焼きを作る。ひな形から実体を作る。タイ焼きの材料、カスタードとかあんことか、それ専門に作る人がいる。タイ焼きを焼く人はその材料をつかって、タイ焼きの型に具材をいれてタイ焼きを作る。全部一から作ろうとしないで、元々あるスクリプト通りに分担してタイ焼きを作る。</p>
<h3>「継承　extend」</h3>
<p>
継承を利用すると同じようなコーディングを複数並べることがあるが、それをextendsで継承することができる。そして子クラスでは、継承以外の（共通機能以外の）機能だけをかくことができる。superを使うときには、親クラスのメソッドをsuper.でつなげて書く。またスーパーは書かなくても自動的に引き継がれている主流は親クラスから継承し子クラスには特有のメソッドを与え、メインメソッドで、子クラスのインスタンスを生成した際にオブジェクトを与えている。抽象的にみて（多態性）車には、トラック、救急車などがある。トラックは「荷物を運ぶ」が仕事であり、救急車は「患者さんを助ける」ことが仕事である。そして車としては「走る」「止まる」ことはかわりませんので、こちらをトラックと救急車には継承することができる。これが継承の考えである。「いちから作るのではなくてテンプレートがあるならテンプレートを複製しましょう」と言うことである。
</p>
<pre>
<code>

//継承　Hero only run and atack. 
public class Hero {
String name =  "Minato";
int hp = 100;
	
public void attack(Matango m) {
System.out.println(this.name + "attack!");
m.hp -=5;
System.out.println("5 points damage");
}
public void run() {
System.out.println(this.name + "run away!");
}
}
//ヒーロークラスをけいしょうしてスパーヒーローを作成する。
//ひーろにある、データはスパーヒーローに反映される。これを継承と呼ぶ。
public class Superhero extends Hero {
boolean flying;
public void fly() {
 this.flying = true;
 System.out.println("he flew out");
　}
public void land() {
this.flying = false;
System.out.println("he arrived at");
　}
 }

//アタックをオーバーライドしたスーパーヒーロー
//ひーろクラスののアタックが修正され、一回の攻撃で敵に与えるダメージが１０
//に修正されたとしても、ダメージのポイントは５＊２のままになってしまう。
public class Superhero extends Hero {
public void attack (Matango m) {
System.out.pprintln(this.name + "attack!");
m.hp=-5;
System.out.println("5 points damage");z
}
if (this.flying) {
System.out.println(this.name + "attack!");
m.hp-=5;
System.out.println("5 points damage");
}
}

//superとは「いまより一つ内側のインスタンス部分」を表す予約語です。これを利用すれば
//親インスタンス部分のメソッドやフィールドに子インスタンス部分からアクセスすることができます。
public class Superhero extends hero {
public void attack (Matango m) {
super.attack (m);
if(this.flying) {
super.attack(m);
}
}
}

//クラス救急車
 public class Ambulance extends Car {
//  番号
private int number = 119;
　
//  コンストラクタ
public Ambulance() {
System.out.println("Ambulanceオブジェクト生成");
}
　
//  救急救命活動
public void sevePeople() {
System.out.println("救急救命活動");
System.out.println("呼び出しは" + number + "番");
}
}

//クラス車
public class Car {
private int fuel = 0; //  燃料
private int migration = 0; //  移動距離
//  コンストラクタ
　
public Car() {
	System.out.println("Carオブジェクト生成");
}
　
//  移動メソッド
public void move() {
//  燃料があるなら移動
if (fuel >= 0) {
	migration++; //  距離移動
	fuel--; //  燃料消費
}
System.out.println("移動距離 : " + migration);
System.out.println("燃料 : " + fuel);
}
　
//  燃料補給メソッド
public void supply(int fuel) {
if (fuel > 0) {
	this.fuel += fuel; //  燃料補給
}
System.out.println("燃料 : " + fuel);
}
　
}

//クラス　メイン
public class SampleEx201 {

public static void main(String[] args) {
// TODO 自動生成されたメソッド・スタブ
Car c = new Car();
c.supply(10); //  燃料補給
c.move(); //  移動
c.move(); //  移動
Ambulance a = new Ambulance();
a.supply(10);
a.move();
a.sevePeople();
}
　
}
</code>
</pre>
<h3>アクセス制御　カプセル化　なぜprivateをつけるのか？</h3>
<p> <a href="https://qiita.com/GleamingCake/items/2b325d189a166ca4f88e">全部 public じゃなんでダメなの？</a></p>
<ul>
<li>privateを使うことによってバグが減らせる。固定値を定めたい時には必ずprivateを使う。バグなんか起きないでしょって思うけど使う。</li>
<li>チームで連携してコードを書いたときに自分が触る場所はprivate以外だとわかりやすい。</li>
</ul>
<h3>「抽象クラス」</h3>
<p>
<a href="https://qiita.com/aiko_han/items/e8ddce85188970fd77da">なぜ抽象クラスを作るのか？</a>なぜ抽象クラス(Abstract)を実装するのか 一つのスーパークラス（Player）の参照変数に他のサブクラス（MusicPlayerとVideoPlayer）のインスタンスを代入できるので、統一した記述方法を使用しながら、それぞれのオーバーライドメソッドを呼び出すことができる！
</p>
<ol>
<li>メソッド名を統一し、ロジックを共通化し、大体何の処理をしているか把握しやすくなる</li>
<li>共通の処理をいちいち全てのクラスに書き込む必要がなくなり、個別の処理も追加しやすくもなる。</li>
<li>開発者がサブクラスを定義した際に、メソッドの実装忘れやメソッド名に間違いがあればコンパイルエラーが起き、コーディングミスを防ぐ</li>
<li>privateにした値を使いたいときはgetterメソッドを使う。</li>
<li>privateにした値を代入したい時はsetterメソッドを使う。</li>
</ol>
<pre>
<code>
//  抽象クラス（鳥）
public abstract class Bird {
//  名前フィールド
private String name;

//  引数つきコンストラクタ
Bird(String name) {
	this.name = name;
}

//  名前の取得
public String getName() {
	return name;
}

//  鳴く（抽象メソッド）
abstract void sing();
}



//  カラスクラス
public class Crow2 extends Bird {
//  コンストラクタ（引数なし）
public Crow2() {
	super("カラス"); //  Birdクラスの引数つきコンストラクタを呼び出す
}

//  カラスがなく
public void sing() {
	System.out.println("カーカー");
}
}




//  すずめクラス
public class Sparrow2 extends Bird {
//  コンストラクタ（引数なし）
public Sparrow2() {
	super("すずめ"); //  Birdクラスの引数つきコンストラクタを呼び出す
}

// 雀が鳴く
public void sing() {
	System.out.println("チュンチュン");
}
}


//オブジェクト生成
public class SampleEx302 {
public static void main(String args[]) {
Cro2 c = new Crow2();
Sparow2 s = new Sparrow2();
// カラスがなく
Sysem.out.print(c.getName() + " : ");
c.sng();
// 雀がなく
Sysem.out.print(s.getName() + " : ");
s.sng();
		
		
//上記のようにも書けるがこちらのほうがさらに簡潔に書けます。
Bird b = new Bird[2];
b[0] = new Crow2();
b[1] = new Sparrow2();
	
for(int i = 0; i&lt; b.length; b++){
	system.out.println(b[i].getName()+ " : ");
	b[i].sing();
}
}
}
</code>
</pre>

<h3>「インターフェイス」</h3>
<p>
抽象クラスとインターフェイスの違いは、内部からアクセスする場合はprivate protectedを使えるabstractを使う。インターフェイスは主に外部へアクセスするときに使う。またインターフェイスクラスで定数を作成することは可能である。<a href="https://camp.trainocate.co.jp/magazine/java-interface-abstract/#:~:text=%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%82%A4%E3%82%B9%E3%81%AF%E3%80%81%E3%81%9D%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%82%A4%E3%82%B9%E5%86%85,%E3%81%AE%E7%99%BA%E7%94%9F%E3%82%92%E9%98%B2%E3%81%92%E3%81%BE%E3%81%99%E3%80%82">Javaのinterfaceとは？インターフェースの使い方やabstractクラスとの違い</a>
</p>

<p>例①　インターフェイスとメインクラス</p>
<pre>
<code>
package exday4;

public interface IPhone {
//電話する
public void call(String number);
}
public interface IEmail {
//  メールを送る
public void sendMail(String address);
}

//  携帯電話クラス
public class CellPhone implements IPhone, IEmail {
//  メールアドレス
private String mailAddress;
//  電話番号
private String number;

//  コンストラクタ（メールアドレスと電話番号を設定
public CellPhone(String mailAddress, String number) {
	this.mailAddress = mailAddress;
	this.number = number;
}

//  指定したメールアドレスにメールを送信する
public void sendMail(String address) {
	System.out.println(address + "に、" + this.mailAddress + "からメールを出します。");
}

//  指定した番号に電話をかける
public void call(String number) {
	System.out.println(number + "に、" + this.number + "から電話をかけます。");
}
}



public class SampleEx401 {

public static void main(String[] args) {
//  携帯電話クラスのインスタンスを生成
CellPhone cp = new CellPhone("hoge@email.com", "090-1234-5678");
//  携帯電話クラスで、電話とメールを送る
cp.call("011-123-4567");
cp.sendMail("fuga@email.com");
//  電話インターフェースでインスタンスにアクセス。
IPhone phone = (IPhone) cp;
//  電話をかける
phone.call("011-987-6543"); 
  //  メールの送信メソッドは利用できない。
//  phone.sendMail("foo@email.com");      
//  メールインターフェースでインスタンスにアクセス。
IEmail mail = (IEmail) cp;
mail.sendMail("bar@email.com"); //  メールを出す
 //  mailインターフェースでは、電話の機能を利用できない。
//mail.call("011-222-3333");       

}
}
</code>
</pre>

<p>例②　インターフェイスとextendsとメインクラス　定数を作れる。extendsとinterfaceを継承した、↓タンク（戦車）クラスに注目。（大）武器→戦車→車、大砲（小）</p>
<pre>
<code>
//  武器クラス
public abstract class Weapon {
private String name = "";

//  コンストラクタ
public Weapon(String name) {
	//  武器の名前を設定
	this.name = name;
}

//  武器の名前を取得
public String getName() {
	return this.name;
}

//  攻撃メソッド
public abstract void attack();
}

public class Tank extends Weapon implements ICar, ICannon {
//  コンストラクタ
public Tank() {
super("戦車");
}

//  大砲を撃つ
public void fire() {
System.out.println("砲撃");
}

//  移動
public void move() {
System.out.println("移動");
}

//  攻撃
public void attack() {
System.out.println(this.getName() + "の攻撃方法");
System.out.println("--------------");
fire();
move();
System.out.println("--------------");
}

}

//  自動車インターフェース
public interface ICar {
public String TYPE_NAME = "car";

//  移動メソッド
public void move();
}

//  大砲インターフェース
public interface ICannon {
public String WEAPON_NAME = "cannon";

//  大砲を撃つ
public void fire();
}

public class SampleEx402 {

public static void main(String[] args) {
Tank t = new Tank();
System.out.println(t.getName() + "の武器の名前:" + Tank.WEAPON_NAME);
System.out.println(t.getName() + "の武器のタイプ:" + Tank.TYPE_NAME);
System.out.println();
t.attack(); //  攻撃
}

}
</code>
</pre>

<h3>「オブジェクト型」</h3>
<p>
すべての継承先元のルートであるため、どのようなインスタンスを生成することもできる。。親クラスの型に子クラスの変数を代入し、インスタンスを生成することをアップキャスト、子クラスの変数に親クラスの変数を代入しインスタンスを生成することをダウンキャストと言う。アップキャストを使うのはOKだけど、ダウンキャストはNO。← 詳細はこちら。<a href="https://qiita.com/RYO-4947123/items/eaeb48b6fcf97c02710f">なぜアップキャストは安全で、ダウンキャストは危険なのか</a>
</p>
<h3>「Map」</h3>
<a href="https://qiita.com/atsuk0r0/items/8d6e4b57821817b65bd0">こちらをまず初めに見るといいです。</a>
<p>
Mapには「キー」と「値」がペアとして格納される。ひとつのキーをひとつの値に対応させなければいけない。つまり、キーが重複してはいけない。<a href="https://qiita.com/yoshi389111/items/7ea0f9b9483b0138ecdf">こちらで学習した。</a>
</p>
<pre>
<code>
public class SampleEx601 {

public static void main(String[] args) {
HashMap&lt;String, Integer> map = new HashMap&lt;>();
String era[] = { "明治", "大正", "昭和", "平成" };
map.put(era[0], 1868);
map.put(era[1], 1912);
map.put(era[2], 1926);
map.put(era[3], 1989);
for (String s : era) {
	System.out.println(s + "元年は、西暦" + map.get(s) + "年");
}
}
}


</code>
</pre>
<h3>「Iterator」</h3>
<p>
コレクションの時に順番通り、出力したい場合またそのほかのadd remove などの処理をしたい場合に用いる。<a href="https://qiita.com/yoshi389111/items/c24f8beefb7b96cad921">こちらを参照にした。</a>
</p>
<pre>
<code>

//////////////ENUM/////////////////////////


from java.util package
import java.util.Enumeration;
import java.util.Vector;

//Main class
public class Main
{
 // Main driver method
 public static void main(String[] args)
 {
 // Creating a vector object
 Vector v = new Vector();
 
// Iterating over vector object
for (int i = 0; i &lt; 10; i++)
      v.addElement(i);
 
// Printing elements in vector object 
System.out.println(v);

// At beginning e(cursor) will point to
// index just before the first element in v
Enumeration e = v.elements();

/ Checking the next element availability where
/ condition holds true till there is a single element
// remaining in the List
  while (e.hasMoreElements())
  {
// Moving cursor to next element
int i = (Integer)e.nextElement();

// Print above elements in object
System.out.print(i + " ");
  }
 }
}

//リストイテレーター

//Importing ArrayList and List iterator classes
//from java.util package
import java.util.ArrayList;
import java.util.ListIterator;

//Main class
public class Main {
// Main driver method
public static void main(String[] args) {
// Creating an object of ArrayList class
ArrayList al = new ArrayList();
　
// Iterating over Arraylist object
for (int i = 0; i &lt; 10; i++)
　
// Adding elements to the Arraylist object
al.add(i);
　
// Print and display all elements inside object
// created above
System.out.println(al);
　
// At beginning ltr(cursor) will point to
// index just before the first element in al
ListIterator ltr = al.listIterator();
　
// Checking the next element availability
while (ltr.hasNext()) {
//  Moving cursor to next element
int i = (Integer) ltr.next();
　
// Getting even elements one by one
System.out.print(i + " ");
　
// Changing even numbers to odd and
// adding modified number again in
// iterator
if (i % 2 == 0) {
// Change to odd
i++;
// Set method to change value
ltr.set(i);
// To add
ltr.add(i);
}
}
　
// Print and display statements
System.out.println();
System.out.println(al);
	}
}


</code>
</pre>

<h3>「エラー　try catch finally」</h3>
<a href="https://qiita.com/ts7i/items/d7f6c1cd5a14e55943d4">段階的に理解する Java 例外処理</a>
<p>
エラー対処に行う。例外がthrowされる可能性のある処理をtryで実行する。例外が発生すると例外処理（catch）をする。finallyはtryもcatchも関係なく必ず最後に実行される。
</p>

<table id="tbl75c" class="cmsTable cmsTableC cmsTable75">
<caption></caption>
<thead><tr>
<th id="null" width="30%">Exception名</th>
<th id="null">概要</th>
</tr></thead><tbody><tr>
<th id="null">NullPointerException</th>
<td id="null">オブジェクトが必要な場合に null に対して操作を試みるなどした場合に発生する例外。</td>
</tr><tr>
<th id="null">ArrayIndexOutOfBoundsException</th>
<td id="null">配列のインデックスなどのインデックスについて、有効な範囲を超えてアクセスした場合に発生する例外。</td>
</tr><tr>
<th id="null">IOException</th>
<td id="null">I/O (入出力) 関連のなんらかの例外が発生したことを示す汎用の例外クラス。</td>
</tr><tr>
<th id="null">ParseException</th>
<td id="null">パース (文字解析) 中になんらかの例外が発生したことを示す例外クラス。</td>
</tr><tr>
<th id="null">SQLException</th>
<td id="null">データベース関連の例外が発生したことを示すための例外クラス。</td>
</tr><tr>
<th id="null">SOAPException</th>
<td id="null">SOAP 関連 (いわゆる XML Web サービス) に関連してなんらかの問題が発生したことを示す例外クラス。</td>
</tr><tr>
<th id="null">TimeoutException</th>
<td id="null">ブロッキング操作 (処理の結果を待つ待ち状態) がタイムアウトによって失敗したことを示す例外クラス。</td>
</tr><tr>
<th id="null">NumberFormatException</th>
<td id="null">このエラーは文字列の値を数値に変換(キャスト）しようとしたが、文字列に数値として正しくない値が設定されている場合に発生する。</td>
</tr><tr>
<th id="null">ClassCastException</th>
<td id="null">このエラーはあるクラスを変換できないクラスにキャストしようとした時に発生する。</td>
</tr><tr>
<th id="null">NumberFormatException</th>
<td id="null">このエラーは文字列の値を数値に変換(キャスト）しようとしたが、文字列に数値として正しくない値が設定されている場合に発生する。</td>
</tr><tr>
<th id="null">ArithmeticException</th>
<td id="null"> 0での除算等、計算で問題が発生した場合に投げられる例外。</td>
</tr></tbody>
<tfoot><tr><td colspan="2"></td></tr></tfoot>
</table>
<pre>
<code>
NullPinterException
nullの値があるかどうかを調べる。
public class Main {
public static void main(String[] args) {
String value = null;

try {
	if (value != null) {
		System.out.println(value);
	} else {
		throw new NullPointerException();
	}
} catch (NullPointerException e) {
	e.printStackTrace();
}

}
}

// 例外処理 - 0除算

public class Main {
    public static void main(String[] args) {
       System.out.println("hello world");
       
      try {
        int number=0;
        int answer = 100 /number;
        System.out.println(answer);
      }catch(Exception e) {
          e.printStackTrace();
      }finally{
         System.out.println("done");
      }
       
       
    }
}

//////////////////////////////////////////////////
//Main.java
package tryCatchError;

class Main {
	public static void main(String args[]) {
		int num1, num2;
		try {
			/* 
			  エラーが起きそうな構文をここに記述する。
			 */
			num1 = 0;
			num2 = 62 / num1;
			System.out.println(num2);
			System.out.println("Hey I'm at the end of try block");
		} catch (ArithmeticException e) {
			/*　  Arithmetic exception がおこったらここが起動する。
			 */
			System.out.println("You should not divide a number by zero");
		} catch (Exception e) {
			/* 
			 *　ここはエラーが起きたらいつでも起動する。
			 */
			System.out.println("Exception occurred");
		}
		System.out.println("I'm out of try-catch block in Java.");
	}
}
</code>
</pre>

<h2 class="animate__animated animate__bounce animate__infinite">ここからDB接続編に入ります。</h2>
<p>MySQL学んでいなければ<a href="mysql_turtorial.html">ここで！</a></p>
<h3>「データベース接続の概要」ステップ１</h3>
<ol>
<li>JDBCドライバのロード</li>
<li>接続の確立</li>
<li>SQL文の送信</li>
<li>抽出結果の取得</li>
<li>接続の解除</li>
</ol>
<ol>
<li>Class.forNameメソッドを使ってドライバをダウンロードします。</li>
<li>DriverManagerクラスのgetConnectionメソッドを使用してデータベースとの接続にひつようなConnectionオブジェクトを取得します。</li>
<li>Statement系オブジェクトのexcuteQueryメソッドやexcuteUpdateメソッドでSQL文をじっこうするようRDBMSに依頼します。</li>
<li>ResultSetオブジェクトでSQLの実行結果が返ってくるので読み取って処理します。</li>
<li>データベースへのアクセスが終了したら明示的に接続を解除する必要があります。Connectionオブジェクト、Statement系オブジェクト、ResultSetオブジェクト、それぞれでcloseメソッドをきどうすることで接続を解除できます。</li>
</ol>
<pre>
<code>
package j4_01;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Sample4_01_1 {

//定数
private static String COMMA = ","; //コンマ

public static void main(String[] args) {
//-------------------------------------------
//データベースへの接続情報
//-------------------------------------------

//JDBCドライバの相対パス
//※バージョンによって変わる可能性があります（MySQL5系の場合は「com.mysql.jdbc.Driver」）
String driverName = "com.mysql.cj.jdbc.Driver";

//接続先のデータベース
//※データベース名が「test_db」でない場合は該当の箇所を変更してください
String jdbcUrl    = "jdbc:mysql://localhost/test_db?characterEncoding=UTF-8&serverTimezone=JST&useSSL=false";

//接続するユーザー名
//※ユーザー名が「test_user」でない場合は該当の箇所を変更してください
String userId     = "test_user";

//接続するユーザーのパスワード
//※パスワードが「test_pass」でない場合は該当の箇所を変更してください
String userPass   = "test_pass";

//-------------------------------------------
//① JDBCドライバのロード
//-------------------------------------------
try {
	Class.forName(driverName);       //JDBCドライバをロード＆接続先として指定
} catch (ClassNotFoundException e) {
	e.printStackTrace();
}


//JDBCの接続に使用するオブジェクトを宣言
//※finallyブロックでも扱うためtryブロック内で宣言してはいけないことに注意
Connection        con = null ;   // Connection（DB接続情報）格納用変数
PreparedStatement ps  = null ;   // PreparedStatement（SQL発行用オブジェクト）格納用変数
ResultSet         rs  = null ;   // ResultSet（SQL抽出結果）格納用変数
</code>
</pre>
<h3>「データベース接続の概要」ステップ2</h3>
<ol>
<li>接続の確立</li>
</ol>

<p>DriverManagerクラス</p>
<p>JDBCドライバマネージャのクラス。JDBCドライバにアクセスそてRDBMSを操作するための様々な機能が提供されている。</p>
<p>getConnectionメソッドでRDBMSに接続し、接続に成功した場合はDB接続に関する情報を有するConnectionオブジェクトを戻り値として返す。引数にDBへの接続情報（接続先DB,ゆーざID、パスワード）を指定することで接続が可能になる。</p>
<pre>
<code>
try {
//-------------------------------------------
// ②接続の確立（Connectionオブジェクトの取得）
//-------------------------------------------
con = DriverManager.getConnection(jdbcUrl, userId, userPass);
</code>
</pre>
<h3>「データベース接続の概要」ステップ3</h3>
<ol>
<li>SQL文の送信</li>
</ol>

<p>Statement系オブジェクト</p>
<p>RDBMSにSQL文を送信する機能を有するオブジェクト*用途によって複数用意される。</p>
<p>SQLを送信する際はまず送信したいSQLをセットし、次に送信するためのメソッドを実行する。このメソッドはSELECT文を送信する場合に用いるexcuteQuery、それ以外に用いるexcuteUpdateの２種類ある。</p>

<pre>
<code>
// ③SQL文の送信 ＆ ④抽出結果の取得
//-------------------------------------------

//SQL文の生成（SELECT）
StringBuffer buf = new StringBuffer() ;
buf.append(" SELECT        ");
buf.append("   id     ,    ");
buf.append("   name   ,    ");
buf.append("   gender ,    ");
buf.append("   age    ,    ");
buf.append("   course      ");
buf.append(" FROM          ");
buf.append("   uzuz_member ");
buf.append(" ORDER BY      ");
buf.append("   id          ");

//PreparedStatementオブジェクトを生成＆発行するSQLをセット
ps = con.prepareStatement(buf.toString());

//SQL文の送信＆抽出結果（ResultSetオブジェクト）の取得
rs = ps.executeQuery();
</code>
</pre>
<h3>「データベース接続の概要」ステップ4</h3>
<ol>
<li>抽出結果の取得。</li>
</ol>

<p>while文rs.nextを使って一行一行データを読み取る。getStringでStringで取得してくれる。そのほかにもgetInt getDoubleがある。</p>

<pre>
<code>
//ResultSetオブジェクトから1レコードずつデータを取得＆加工＆表示する
while (rs.next()) {

//1レコード分のデータを取得＆加工（各カラムをコンマ綴りで結合）
StringBuffer rsbuf = new StringBuffer();
rsbuf.append(rs.getString("id"));
rsbuf.append(COMMA);
rsbuf.append(rs.getString("name"));
rsbuf.append(COMMA);
rsbuf.append(rs.getString("gender"));
rsbuf.append(COMMA);
rsbuf.append(rs.getString("age"));
rsbuf.append(COMMA);
rsbuf.append(rs.getString("course"));

//加工作成した1レコード分のデータを表示
System.out.println(rsbuf.toString());
}
</code>
</pre>
<h3>「データベース接続の概要」ステップ5</h3>
<ol>
<li>接続の解除。</li>
</ol>

<p></p>

<pre>
<code>
catch (SQLException e) {
e.printStackTrace();

} finally {
//-------------------------------------------
// ⑤接続の解除
//-------------------------------------------

//ResultSetオブジェクトの接続解除
if (rs != null) {    //接続が確認できている場合のみ実施
	try {
		rs.close();  //接続の解除
	} catch (SQLException e) {
		e.printStackTrace();
	}
}

//PreparedStatementオブジェクトの接続解除
if (ps != null) {    //接続が確認できている場合のみ実施
	try {
		ps.close();  //接続の解除
	} catch (SQLException e) {
		e.printStackTrace();
	}
}

//Connectionオブジェクトの接続解除
if (con != null) {    //接続が確認できている場合のみ実施
try {
	con.close();  //接続の解除
} catch (SQLException e) {
	e.printStackTrace();
}
}
}
}
}
}
</code>
</pre>

<h3>「データベース接続の概要」全部のコード</h3>
<pre>
<code>
package j4_01;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Sample4_01_1 {

//定数
private static String COMMA = ","; //コンマ
public static void main(String[] args) {
//-------------------------------------------
//データベースへの接続情報
//-------------------------------------------

//JDBCドライバの相対パス
//※バージョンによって変わる可能性があります（MySQL5系の場合は「com.mysql.jdbc.Driver」）
String driverName = "com.mysql.cj.jdbc.Driver";

//接続先のデータベース
//※データベース名が「test_db」でない場合は該当の箇所を変更してください
String jdbcUrl    = "jdbc:mysql://localhost/test_db?characterEncoding=UTF-8&serverTimezone=JST&useSSL=false";

//接続するユーザー名
//※ユーザー名が「test_user」でない場合は該当の箇所を変更してください
String userId     = "test_user";

//接続するユーザーのパスワード
//※パスワードが「test_pass」でない場合は該当の箇所を変更してください
String userPass   = "test_pass";

//-------------------------------------------
//① JDBCドライバのロード
//-------------------------------------------
try {
	Class.forName(driverName);       //JDBCドライバをロード＆接続先として指定
} catch (ClassNotFoundException e) {
	e.printStackTrace();
}


//JDBCの接続に使用するオブジェクトを宣言
//※finallyブロックでも扱うためtryブロック内で宣言してはいけないことに注意
Connection        con = null ;   // Connection（DB接続情報）格納用変数
PreparedStatement ps  = null ;   // PreparedStatement（SQL発行用オブジェクト）格納用変数
ResultSet         rs  = null ;   // ResultSet（SQL抽出結果）格納用変数

try {
//-------------------------------------------
// ②接続の確立（Connectionオブジェクトの取得）
//-------------------------------------------
con = DriverManager.getConnection(jdbcUrl, userId, userPass);

//-------------------------------------------
// ③SQL文の送信 ＆ ④抽出結果の取得
//-------------------------------------------

//SQL文の生成（SELECT）
StringBuffer buf = new StringBuffer() ;
buf.append(" SELECT        ");
buf.append("   id     ,    ");
buf.append("   name   ,    ");
buf.append("   gender ,    ");
buf.append("   age    ,    ");
buf.append("   course      ");
buf.append(" FROM          ");
buf.append("   uzuz_member ");
buf.append(" ORDER BY      ");
buf.append("   id          ");

//PreparedStatementオブジェクトを生成＆発行するSQLをセット
ps = con.prepareStatement(buf.toString());

//SQL文の送信＆抽出結果（ResultSetオブジェクト）の取得
rs = ps.executeQuery();

//ResultSetオブジェクトから1レコードずつデータを取得＆加工＆表示する
while (rs.next()) {

//1レコード分のデータを取得＆加工（各カラムをコンマ綴りで結合）
StringBuffer rsbuf = new StringBuffer();
rsbuf.append(rs.getString("id"));
rsbuf.append(COMMA);
rsbuf.append(rs.getString("name"));
rsbuf.append(COMMA);
rsbuf.append(rs.getString("gender"));
rsbuf.append(COMMA);
rsbuf.append(rs.getString("age"));
rsbuf.append(COMMA);
rsbuf.append(rs.getString("course"));

//加工作成した1レコード分のデータを表示
System.out.println(rsbuf.toString());
}

} catch (SQLException e) {
	e.printStackTrace();

} finally {
//-------------------------------------------
// ⑤接続の解除
//-------------------------------------------

//ResultSetオブジェクトの接続解除
if (rs != null) {    //接続が確認できている場合のみ実施
	try {
		rs.close();  //接続の解除
	} catch (SQLException e) {
		e.printStackTrace();
	}
}

//PreparedStatementオブジェクトの接続解除
if (ps != null) {    //接続が確認できている場合のみ実施
	try {
		ps.close();  //接続の解除
	} catch (SQLException e) {
		e.printStackTrace();
	}
}

//Connectionオブジェクトの接続解除
if (con != null) {    //接続が確認できている場合のみ実施
	try {
		con.close();  //接続の解除
	} catch (SQLException e) {
		e.printStackTrace();
	}
}
		}
	}
}

</code>
</pre>

</body>

</html>